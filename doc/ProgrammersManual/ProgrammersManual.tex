%\documentclass[11pt]{article}
\documentclass{asme2ej}
\usepackage{amsmath,amssymb,graphicx,bm}
\usepackage{listings, xcolor, subcaption, placeins}
\usepackage{undertilde}
\usepackage{algorithm,algpseudocode}
\usepackage{multicol}
\usepackage{makecell}
\usepackage{longtable}
\usepackage[longtable]{colortbl}
\graphicspath{{./images}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% If you want to define a new command, you can do it like this:
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\e}{\bm{e}}
\newcommand{\TEN}[1]{\underline{\underline{#1}}}
\newcommand{\VEC}[1]{\utilde{#1}}
\newcommand{\UVEC}[1]{\underline{#1}}
\newcommand{\PK}[1]{\TEN{\tau}^{(#1)}}
\newcommand{\cauchy}{\TEN{\sigma}}
\newcommand{\st}{$^{\text{st}}$}
\newcommand{\nd}{$^{\text{nd}}$}
\newcommand\defeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{=}}}

\graphicspath{{./images/}}

%% If you want to use a function like ''sin'' or ''cos'', you can do it like this
%% (we probably won't have much use for this)
% \DeclareMathOperator{\sin}{sin}   %% just an example (it's already defined)


\begin{document}
\title{Programmers Manual}
\author{Nathan Miller}

\maketitle

\begin{abstract}

This is intended to provide information on the major modules and functions contained within the user element and testing framework. Focus will be placed on requirements for the development of additional constitutive models and the connections of the UEL with Abaqus.

\end{abstract}

\tableofcontents

\section{fea\_driver.py}

\subsection{Description}

The overall driver code for the UEL. This code is considered to be largely auxillary to the fundamental aim of the project which is the development of a user element for Abaqus. It is useful however to verify that the element is working correctly outside of the confines of Abaqus itself. This allows for the element to be verified individually and then as a part of the whole.

\subsection{Classes}



\subsection{Functions}



\section{micro\_element.py}

\subsection{Description}

The definition of the micromorphic finite element. The element is an eight noded, linear hexehedral element with twelve degrees of freedom per node. These degrees of freedom are described in table~\ref{table:nodal_dof}.

\begin{table}
\centering
\begin{tabular}{c c}
\hline
Degree of freedom & Description \\
\hline
\hline
$u_1$ & Displacement degree of freedom in the 1 direction\\
%\hline
$u_2$ & Displacement degree of freedom in the 2 direction\\
%\hline
$u_3$ & Displacement degree of freedom in the 3 direction\\
%\hline
$\phi_{11}$ & The 11 component of the micro-displacement tensor\\
%\hline
$\phi_{22}$ & The 22 component of the micro-displacement tensor\\
%\hline
$\phi_{33}$ & The 33 component of the micro-displacement tensor\\
%\hline
$\phi_{23}$ & The 23 component of the micro-displacement tensor\\
%\hline
$\phi_{13}$ & The 13 component of the micro-displacement tensor\\
%\hline
$\phi_{12}$ & The 12 component of the micro-displacement tensor\\
%\hline
$\phi_{32}$ & The 32 component of the micro-displacement tensor\\
%\hline
$\phi_{31}$ & The 31 component of the micro-displacement tensor\\
%\hline
$\phi_{21}$ & The 21 component of the micro-displacement tensor\\
\hline
\end{tabular}
\caption{Nodal degrees of freedom}
\label{table:nodal_dof}
\end{table}

This module performs the parsing of the Abaqus inputs, and will provide the residual vector (Abaqus' RHS) the Jacobian (Abaqus' AMATRX), and other quantities such as the mass matrix (to be implemented).

\subsection{Functions}

\section{micromorphic\_linear\_elasticity.py}

\subsection{Description}

\subsection{Classes}

\subsubsection{TestMicro\_LE}

The function testing class

\begin{longtable}{ p{.40\textwidth}  p{.60\textwidth} }
\hline
Method & Description\\
\hline
\hline
run & A redefinition of the parent run method which allows for recording the results of the tests.\\
setUp & A redefinition of the setUp method used for recording the results. Called for each test.\\
tearDown & A redefinition of the tearDown method used for recording the results. Called for each test.\\
test\_compute\_dCinvdC & Test the computation of the derivative of the inverse of the right Cauchy-Green deformation tensor w.r.t. the right Cauchy-Green deformation tensor C\\
test\_compute\_deformation\_measures & Test the computation of the deformation measures \\
test\_compute\_ho\_stress & Test the computation of the higher order stress\\
test\_compute\_pk2\_stress & Test the computation of the second Piola-Kirchhoff stress\\
test\_compute\_strain\_measures & Test the computation of the strain measures\\
test\_compute\_stress\_derivatives & Test the computation of the stress derivatives with respect to the deformation measures\\
test\_compute\_stress\_derivatives\_wrt\_C(self) & Test the computation of the stress derivatives wrt the right Cauchy-Green deformation tensor\\
test\_compute\_stress\_derivatives\_wrt\_Gamma & Test the computation of the stress derivatives wrt the deformation measure Gamma\\
test\_compute\_stress\_derivatives\_wrt\_Psi & Test the computation of the stress derivatives wrt the deformation measure Psi\\
test\_compute\_stresses & Test the computation of all of the stress measures\\
test\_compute\_symmetric\_stress &  Test the computation of the symmetric stress\\
test\_form\_A & Test forming the A stiffness tensor\\
test\_form\_B & Test forming the B stiffness tensor\\
test\_form\_C & Test forming the C stiffness tensor\\
test\_form\_D & Test forming the D stiffness tensor\\
test\_form\_stiffness\_tensors & Test forming the stiffness tensors\\
test\_micromorphic\_linear\_elasticity & Test the main function for the micromorphic linear elasticity model\\
setUpClass & A redefinition of setUpClass which is run once at the initialization of the class. This opens a file to write the results to and initializes it.\\
tearDownClass & A redefinition of tearDownClass which is run once when the class exits. This closes the results file.\\
\hline
\end{longtable}

\subsubsection{Data and attributes}
\begin{longtable}{ p{.30\textwidth}  p{.70\textwidth} }
\hline
Data and Attribute & Decription\\
\hline
\hline
currentResult & The current result of a given test simulation\\
f & The output file the results of the tests are being written to\\
module\_name & The name of the module\\
original\_directory & The original directory of the module\\
output\_file\_location & The location where the output file should be stored\\
output\_file\_name & The name of the output file\\
\hline
\end{longtable}

\subsection{Functions}

\begin{longtable}{p{.40\textwidth} p{0.60\textwidth}}
\hline
Function & Description\\
\hline
\hline
compute\_dCinvdC & Compute the derivative of the inverse of the right Cauchy-Green deformation tensor w.r.t. the right Cauchy-Green deformation tensor C\\
compute\_deformation\_measures & Compute the deformation measures \\
compute\_ho\_stress & Compute the higher order stress\\
compute\_pk2\_stress & Compute the second Piola-Kirchhoff stress\\
compute\_strain\_measures & Compute the strain measures\\
compute\_stress\_derivatives & Compute the stress derivatives with respect to the deformation measures\\
compute\_stress\_derivatives\_wrt\_C(self) & Compute the stress derivatives wrt the right Cauchy-Green deformation tensor\\
compute\_stress\_derivatives\_wrt\_Gamma & Compute the stress derivatives wrt the deformation measure Gamma\\
compute\_stress\_derivatives\_wrt\_Psi & Compute the stress derivatives wrt the deformation measure Psi\\
compute\_stresses & Compute all of the stress measures\\
compute\_symmetric\_stress &  Compute the symmetric stress\\
form\_A & Form the A stiffness tensor\\
form\_B & Form the B stiffness tensor\\
form\_C & Form the C stiffness tensor\\
form\_D & Form the D stiffness tensor\\
form\_stiffness\_tensors & Form the stiffness tensors\\
micromorphic\_linear\_elasticity & The main function for the micromorphic linear elasticity model\\
\hline
\end{longtable}

\clearpage
\section{hex8.py}

\subsection{Description}

Utility functions used in the computation of the shape functions for the eight noded hexahedral element. This module should contain general functions used in accessing the tensor datastructures and common functions which are not necessarily specific to the element.

\subsection{Classes}

\subsubsection{TestHex8}

The function testing class

\begin{longtable}{ p{.30\textwidth}  p{.70\textwidth} }
\hline
Method & Description\\
\hline
\hline
run & A redefinition of the parent run method which allows for recording the results of the tests.\\
setUp & A redefinition of the setUp method used for recording the results. Called for each test.\\
tearDown & A redefinition of the tearDown method used for recording the results. Called for each test.\\
BVoigt\_submatrix & A test of the function which creates a submatrix of the the strain displacement matrix\\
Hex8\_get\_shape\_function\_info & A test of the function which returns the shape function value, the gradient of the shape function, and the determinant of the jacobian in the local coordinate system of a specified node at a specified local coordinate.\\
Hex8\_global\_grad\_shape\_function & A test of the computation of the global gradient of the shape function for a specified node at a specified local coordinate\\
Hex8\_interpolation\_matrix & A test of the forming of the interpolation matrix.\\
Hex8\_local\_grad\_shape\_function & A test of the computation of the local gradient of the shape function for a specified node at a specified local coordinate\\
Hex8\_shape\_function & A test of the computation of the shape function for a specified node at a specified local position\\
Hex8\_shape\_function\_loc & A test of the computation of the shape function for a specified node, at a specified local position, with specified nodal coordinates\\
T\_to\_V\_mapping & A test of the mapping from tensor indices to the vector form index\\
V\_to\_T\_mapping & A test of the mapping from a vector index to the tensor form indices\\
compute\_BVoigt & A test of the computation of the strain displacement matrix in Voigt notation\\
convert\_M\_to\_V & A test of the conversion of a tensor in matrix form to a tensor in vector form\\
convert\_V\_to\_T & A test of the conversion of a tensor in vector form to a tensor in matrix form\\
convert\_V\_to\_T & A test of the conversion of a tensor in vector form to the full tensor representation\\
get\_1D\_gpw & A test of the function which returns the one dimensional gauss points and weights\\
get\_all\_shape\_function\_info & A test of the function that computes and returns the value of all of the nodal shape functions, global gradients, and determinants of the jacobians of transformation to the local coordinates\\
get\_global\_gradients & A test of the function which computes and returns all of the global gradients of the shape functions and the determinants of the jacobians of transformation to the local coordinates\\
get\_gpq & A test of the function which returns the 3D gauss points\\
get\_jacobian & A test of the computation of the jacobian of the transformation to the local coordinates\\
get\_shape\_functions & A test of the function which computes the shape\\ functions.\\
get\_symm\_matrix & Test for the function which returns the symmetric part of a matrix\\
get\_symm\_matrix\_V & Test getting the symmetric part of a matrix in vector form\\
invert\_3x3\_matrix &= Test the inversion of a 3 by 3 matrix\\
invert\_3x3\_matrix\_V & Test the inversion of a 3 by 3 matrix in vector form\\
matrix\_Tdot & Test the dot product of two matrices where the first one is transposed\\
matrix\_Tdot\_TOT & Test the dot product of a transposed matrix and a third order tensor\\
matrix\_Tdot\_V & Test the dot product of a transposed matrix and another matrix in vector form.\\
matrix\_dot & Test the dot product of two matrices\\
matrix\_dot\_V & Test the dot product of two matrices in vector form\\
reduce\_tensor\_to\_matrix\_form & Test the reduction of a tensor to matrix form\\
vector\_dot\_matrix & Test the dot product of a vector and a matrix\\
vector\_dyadic\_product & Test the dyadic product of two vectors\\
setUpClass & A redefinition of setUpClass which is run once at the initialization of the class. This opens a file to write the results to and initializes it.\\
tearDownClass & A redefinition of tearDownClass which is run once when the class exits. This closes the results file.\\
\hline
\end{longtable}

\subsubsection{Data and attributes}
\begin{longtable}{ p{.30\textwidth}  p{.70\textwidth} }
\hline
Data and Attribute & Decription\\
\hline
\hline
currentResult & The current result of a given test simulation\\
f & The output file the results of the tests are being written to\\
module\_name & The name of the module\\
original\_directory & The original directory of the module\\
output\_file\_location & The location where the output file should be stored\\
output\_file\_name & The name of the output file\\
\hline
\end{longtable}

\subsection{Functions}

\begin{longtable}{ p{.30\textwidth}  p{.70\textwidth} }
\hline
Function & Description\\
\hline
\hline
BVoigt\_submatrix & The function which creates a submatrix of the the strain displacement matrix\\
Hex8\_get\_shape\_function\_info & The function which returns the shape function value, the gradient of the shape function, and the determinant of the jacobian in the local coordinate system of a specified node at a specified local coordinate.\\
Hex8\_global\_grad\_shape\_function & Computes of the global gradient of the shape function for a specified node at a specified local coordinate\\
Hex8\_interpolation\_matrix & Forms of the interpolation matrix.\\
Hex8\_local\_grad\_shape\_function & Computes the local gradient of the shape function for a specified node at a specified local coordinate\\
Hex8\_shape\_function & Computes the shape function for a specified node at a specified local position\\
Hex8\_shape\_function\_loc & Computes the shape function for a specified node, at a specified local position, with specified nodal coordinates\\
T\_to\_V\_mapping & Returns the mapping from tensor indices to the vector form index\\
V\_to\_T\_mapping & Returns the mapping from a vector index to the tensor form indices\\
compute\_BVoigt & Returns the computation of the strain displacement matrix in Voigt notation\\
convert\_M\_to\_V & Converts a tensor in matrix form to a tensor in vector form\\
convert\_V\_to\_T & Converts a tensor in vector form to a tensor in matrix form\\
convert\_V\_to\_T & Converts a tensor in vector form to the full tensor representation\\
get\_1D\_gpw & Returns the one dimensional gauss points and weights\\
get\_all\_shape\_function\_info & Computes and returns the value of all of the nodal shape functions, global gradients, and determinants of the jacobians of transformation to the local coordinates\\
get\_global\_gradients & Computes and returns all of the global gradients of the shape functions and the determinants of the jacobians of transformation to the local coordinates\\
get\_gpq & Returns the 3D gauss points\\
get\_jacobian & A test of the computation of the jacobian of the transformation to the local coordinates\\
get\_shape\_functions &Computes the shape\\ functions.\\
get\_symm\_matrix & Returns the symmetric part of a matrix\\
get\_symm\_matrix\_V & Returns the symmetric part of a matrix in vector form\\
invert\_3x3\_matrix &=Inverts a 3 by 3 matrix\\
invert\_3x3\_matrix\_V & Inverts a 3 by 3 matrix in vector form\\
matrix\_Tdot & Computes the dot product of two matrices where the first one is transposed\\
matrix\_Tdot\_TOT & Computes the dot product of a transposed matrix and a third order tensor\\
matrix\_Tdot\_V & Computes the dot product of a transposed matrix and another matrix in vector form.\\
matrix\_dot & Computes the dot product of two matrices\\
matrix\_dot\_V & Computes the dot product of two matrices in vector form\\
reduce\_tensor\_to\_matrix\_form & Reduces a tensor to matrix form\\
vector\_dot\_matrix & Computes the dot product of a vector and a matrix\\
vector\_dyadic\_product & Computes the dyadic product of two vectors\\
\hline
\end{longtable}

\FloatBarrier

\bibliographystyle{asme2ej}
\bibliography{micromorphic}

\end{document}