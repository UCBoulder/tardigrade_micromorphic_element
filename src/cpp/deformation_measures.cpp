/*!===========================================================================
   |                                                                         |
   |                        deformation_measures.cpp                         |
   |                                                                         |
   ===========================================================================
   | The source file for a wrapper that converts variables and their         |
   | gradients generated by MOOSE into deformation measures which can be     |
   | used to compute the micromorphic stress measures and their tangents.    |
   | This is done to avoid any possible assumptions of symmetry which could  |
   | be present in the Tensor Mechanics physics module.                      |
   ===========================================================================
   | Dependencies:                                                           |
   |     Eigen: A matrix library available at eigen.tuxfamily.org            |
   ===========================================================================
   */

#include<deformation_measures.h>

namespace deformation_measures

{

    void get_deformation_gradient(const double (&_grad_u)[3][3], Matrix_3x3 &F){

        /*!==================================
           |    get_deformation_gradient    |
           ==================================

           Compute the deformation gradient from the 
           gradients of the displacements. The deformation 
           gradient can be computed via

           Finv(i,j) = eye(i,j) - _grad_u[i][j]

           where Finv is the inverse of the deformation gradient.

        */

        for (int i=0; i<3; i++){

            for (int j=0; j<3; j++){

                F(i,j) = -_grad_u[i][j];

            }

        }

        for (int i=0; i<3; i++){F(i,i) += 1;}

        F = F.inverse().eval();

        return;
    }

    void assemble_chi(const double (&_phi)[9], Matrix_3x3 &chi){

        /*!======================
           |    assemble_chi    |
           ======================

           Assemble the micro-deformation 
           tensor chi from the phi degrees of 
           freedom.

           _phi is assumed to be organized in 
           Voigt notation form i.e.

           phi_11, phi_22, phi_33, phi_23, phi_13, phi_12, phi_32, phi_31, phi_21

        */

        chi(0,0) = 1. + _phi[0];
        chi(1,1) = 1. + _phi[1];
        chi(2,2) = 1. + _phi[2];
        chi(1,2) = _phi[3];
        chi(0,2) = _phi[4];
        chi(0,1) = _phi[5];
        chi(2,1) = _phi[6];
        chi(2,0) = _phi[7];
        chi(1,0) = _phi[8];

    }

    void assemble_grad_chi(const double (&_grad_phi)[9][3], const Matrix_3x3 &F, Matrix_3x9 &grad_chi){

        /*!==========================
          |    assemble_grad_chi    |
          ===========================

          Assemble the gradient of chi w.r.t. the 
          reference coordinates.

          _grad_phi is assumed to be organized

          _grad_phi[I][k] = phi_iI,k

          where I is a ``super'' index which has the form

               0  1  2  3  4  5  6  7  8
          I = 11,22,33,23,13,12,32,31,21

          and k ranges from

              0  1  2
          k = 1, 2, 3

          We will map _phi_iI,k back to the reference 
          coordinates via

          _phi_iI,J = _phi_iI,k F_kJ

          and then assemble it into the required matrix form.


        */


        //We map the gradient from the current configuration to 
        //the reference configuration.
        double _grad_phi_map[9][3];

        for (int I=0; I<9; I++){

            for (int J=0; J<3; J++){

                _grad_phi_map[I][J] = 0.;

                for (int k=0; k<3; k++){

                    _grad_phi_map[I][J] += _grad_phi[I][k]*F(k,J);

                }

            }

        }

        grad_chi(0,0) = _grad_phi_map[0][0]; //111
        grad_chi(0,1) = _grad_phi_map[5][1]; //122
        grad_chi(0,2) = _grad_phi_map[4][2]; //133
        grad_chi(0,3) = _grad_phi_map[5][2]; //123
        grad_chi(0,4) = _grad_phi_map[0][2]; //113
        grad_chi(0,5) = _grad_phi_map[0][1]; //112
        grad_chi(0,6) = _grad_phi_map[4][1]; //132
        grad_chi(0,7) = _grad_phi_map[4][0]; //131
        grad_chi(0,8) = _grad_phi_map[5][0]; //121
        
        grad_chi(1,0) = _grad_phi_map[8][0]; //211
        grad_chi(1,1) = _grad_phi_map[1][1]; //222
        grad_chi(1,2) = _grad_phi_map[3][2]; //233
        grad_chi(1,3) = _grad_phi_map[1][2]; //223
        grad_chi(1,4) = _grad_phi_map[8][2]; //213
        grad_chi(1,5) = _grad_phi_map[8][1]; //212
        grad_chi(1,6) = _grad_phi_map[3][1]; //232
        grad_chi(1,7) = _grad_phi_map[3][0]; //231
        grad_chi(1,8) = _grad_phi_map[1][0]; //221

        grad_chi(2,0) = _grad_phi_map[7][0]; //311
        grad_chi(2,1) = _grad_phi_map[6][1]; //322
        grad_chi(2,2) = _grad_phi_map[2][2]; //333
        grad_chi(2,3) = _grad_phi_map[6][2]; //323
        grad_chi(2,4) = _grad_phi_map[7][2]; //313
        grad_chi(2,5) = _grad_phi_map[7][1]; //312
        grad_chi(2,6) = _grad_phi_map[2][1]; //332
        grad_chi(2,7) = _grad_phi_map[2][0]; //331
        grad_chi(2,8) = _grad_phi_map[6][0]; //321

        return;

    }

    void get_right_cauchy_green(const Matrix_3x3 &F, Matrix_3x3 &RCG){
        /*!================================
           |    get_right_cauchy_green    |
           ================================

           Get the right Cauchy-Green deformation 
           tensor.

           C_IJ = F_iI F_iJ

        */

        RCG = F.transpose()*F;
        return;
    }

    void get_left_cauchy_green(const Matrix_3x3 &F, Matrix_3x3 &LCG){

        /*!===============================
           |    get_left_cauchy_green    |
           ===============================

           Get the left Cauchy-Green deformation
           tensor.

           b_ij = F_iI F_jI

        */

        LCG = F*F.transpose();
        return;
    }

    void get_lagrange_strain(const Matrix_3x3 &F, Matrix_3x3& E){

        /*!=============================
           |    get_lagrange_strain    |
           =============================

           Get the lagrange strain tensor.

           E_IJ = 0.5*(F_iI F_iJ - I_IJ)

        */

        E = 0.5*F.transpose()*F;
        for (int i=0; i<3; i++){E(i,i) -= 0.5;}

        return;
    }

    void get_almansi_strain(const Matrix_3x3 &F, Matrix_3x3 &e){
        /*!============================
           |    get_almansi_strain    |
           ============================

           Compute the almansi strain.

           e_ij = 0.5*(I_ij - (F_iI F_jI)**-1)

        */

        e = -0.5*(F*F.transpose()).inverse();
        for (int i=0; i<3; i++){e(i,i) += 0.5;}
        return;
    }

    void get_small_strain(const double (&_grad_u)[3][3], Matrix_3x3 &epsilon){
         /*!=========================
           |    get_small_strain    |
           ==========================

           Compute the small strain tensor.

           epsilon(i,j) = 0.5*(_grad_u[i][j] + _grad_u[j][i])

         */

         for (int i=0; i<3; i++){

             for (int j=0; j<3; j++){

                 epsilon(i,j) = 0.5*(_grad_u[i][j] + _grad_u[j][i]);

             }
         }
             
         return;
    }

    void get_psi(const Matrix_3x3 &F, const Matrix_3x3 &chi, Matrix_3x3 &psi){
        /*!=================
           |    get_psi    |
           =================

           Compute the mixed deformation measure psi.

           psi_IJ = F_iI chi_iJ

        */

        psi = F.transpose()*chi;

        return;
    }

    void get_micro_strain(const Matrix_3x3 &psi, Matrix_3x3 &E_micro){
        /*==========================
          |    get_micro_strain    |
          ==========================

          Compute the micromorphic strain.

          E_micro_IJ = psi_IJ - eye_IJ

        */

        E_micro = psi - Matrix_3x3::Identity();

        return;
    }

    void get_gamma(const Matrix_3x3 &F, const Matrix_3x9 &grad_chi, Matrix_3x9 &gamma){
        /*!===================
           |    get_gamma    |
           ===================

           Compute the value of the mixed deformation measure gamma.

           gamma_IJK = F_iI chi_iJ,K

           The form provided here is gamma_IJ

           where
                0   1   2   3   4   5   6   7   8
           J = 11, 22, 33, 23, 13, 12, 32, 31, 21

        */

        gamma = F.transpose()*grad_chi;

        return;
    }

    void voigt_3x3_symm_tensor(const Matrix_3x3 &A, Vector_6 &v){
        /*!==============================
           |    voigt_3x3_symm_tensor   |
           ==============================

           Create the voigt notation of a symmetric second order tensor.

        */

        v(0) = A(0,0);
        v(1) = A(1,1);
        v(2) = A(2,2);
        v(3) = A(1,2);
        v(4) = A(0,2);
        v(5) = A(0,1);

        return;
    }

    void voigt_3x3_tensor(const Matrix_3x3 &A, Vector_9 &v){
        /*!=========================
           |    voigt_3x3_tensor   |
           =========================

           Create the voigt notation of a general second order tensor.

        */

        v(0) = A(0,0);
        v(1) = A(1,1);
        v(2) = A(2,2);
        v(3) = A(1,2);
        v(4) = A(0,2);
        v(5) = A(0,1);
        v(6) = A(2,1);
        v(7) = A(2,0);
        v(8) = A(1,0);

        return;
    }

    void get_sot_to_voigt_map(int (&sot_to_voigt_map)[3][3]){
        /*!==============================
        |    get_sot_to_voigt_map    |
        ==============================

        Get the second order tensor to voigt map.

        */

        sot_to_voigt_map[0][0] = 0;
        sot_to_voigt_map[1][1] = 1;
        sot_to_voigt_map[2][2] = 2;
        sot_to_voigt_map[1][2] = 3;
        sot_to_voigt_map[0][2] = 4;
        sot_to_voigt_map[0][1] = 5;
        sot_to_voigt_map[2][1] = 6;
        sot_to_voigt_map[2][0] = 7;
        sot_to_voigt_map[1][0] = 8;

        return;
    }

    void get_tot_to_voigt_map(int (&tot_to_voigt_map)[3][3][3]){
        /*!==============================
        |    get_tot_to_voigt_map    |
        ==============================

        Get the third order tensor to voigt map.

        */

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        for (int i=0; i<3; i++){

            for (int j=0; j<3; j++){

                for (int k=0; k<3; k++){

                    tot_to_voigt_map[i][j][k] = sot_to_voigt_map[j][k] + 9*i;

                }

            }

        }

        return;
    }
    
    void undo_voigt_3x3_tensor(const Vector_9 &v, Matrix_3x3 &A){
        /*!===============================
           |    undo_voigt_3x3_tensor    |
           ===============================
        
           Undo the voigt notation on a vector of length 9.
        
        */
        
        A(0,0) = v(0);
        A(1,1) = v(1);
        A(2,2) = v(2);
        A(1,2) = v(3);
        A(0,2) = v(4);
        A(0,1) = v(5);
        A(2,1) = v(6);
        A(2,0) = v(7);
        A(1,0) = v(8);
    }

    void voigt_3x9_tensor(const Matrix_3x9 &A, Vector_27 &v){
        /*!==========================
           |    voigt_3x9_tensor    |
           ==========================

           Create the voigt notation of a general third order tensor
           which has the second two indices are in voigt notation already.

        */

        for (int i=0; i<3; i++){

            for (int j=0; j<9; j++){
                v(i*9 + j) = A(i,j); 
            }

        }
        return;
    }
    
    void undo_voigt_3x9_tensor(const Vector_27 &v, Matrix_3x9 &A){
        /*!===============================
           |    undo_voigt_3x9_tensor    |
           ===============================

           Undo the voigt notation of a general third order tensor
           which has the second two indices are in voigt notation already.

        */

        for (int i=0; i<3; i++){

            for (int j=0; j<9; j++){
                A(i,j) = v(i*9 + j);
            }

        }
        return;
    }
    
    void perform_left_positive_cyclic_permutation(Vector_27 &A){
        /*!==========================================
           |    perform_left_cyclic_permutation    |
           ==========================================
          
           Perform a left positive cyclic permutation on a third order tensor in vector form i.e.
           
           A_ijk -> A_jki
        
        */
        
        Vector_27 swap;
        
        swap[0] = A[0];
        swap[1] = A[14];
        swap[2] = A[22];
        swap[3] = A[23];
        swap[4] = A[18];
        swap[5] = A[9];
        swap[6] = A[13];
        swap[7] = A[4];
        swap[8] = A[5];
        swap[9] = A[8];
        swap[10] = A[10];
        swap[11] = A[21];
        swap[12] = A[19];
        swap[13] = A[26];
        swap[14] = A[17];
        swap[15] = A[12];
        swap[16] = A[3];
        swap[17] = A[1];
        swap[18] = A[7];
        swap[19] = A[15];
        swap[20] = A[20];
        swap[21] = A[24];
        swap[22] = A[25];
        swap[23] = A[16];
        swap[24] = A[11];
        swap[25] = A[2];
        swap[26] = A[6];
        
        A = swap;
        
    }

    void perform_right_positive_cyclic_permutation(Vector_27 &A){
        /*!==========================================
           |    perform_right_cyclic_permutation    |
           ==========================================
          
           Perform a right positive cyclic permutation on a third order tensor in vector form i.e.
           
           A_ijk -> A_kij
        
        */
        
        Vector_27 swap;
        
        swap[0] = A[0];
        swap[1] = A[17];
        swap[2] = A[25];
        swap[3] = A[16];
        swap[4] = A[7];
        swap[5] = A[8];
        swap[6] = A[26];
        swap[7] = A[18];
        swap[8] = A[9];
        swap[9] = A[5];
        swap[10] = A[10];
        swap[11] = A[24];
        swap[12] = A[15];
        swap[13] = A[6];
        swap[14] = A[1];
        swap[15] = A[19];
        swap[16] = A[23];
        swap[17] = A[14];
        swap[18] = A[4];
        swap[19] = A[12];
        swap[20] = A[20];
        swap[21] = A[11];
        swap[22] = A[2];
        swap[23] = A[3];
        swap[24] = A[21];
        swap[25] = A[22];
        swap[26] = A[13];
        
        A = swap;
        
    }
    
    void dot_2ot_4ot(const int &index, const int &mode, const Matrix_3x3 &sot, const Matrix_9x9 &fot, Matrix_9x9 &result){
        /*!==================
        |    dot_2ot_4ot    |
        =====================
        
        Compute the dot product of a second order tensor and a fourth order tensor at index i+1 i.e.
        
        index = 0, mode=0
        
        result_ijkl = sot_im fot_mjkl
        
        index = 1, mode=0
        
        result_ijkl = sot_im fot_jmkl
        
        index = 0, mode=1
        
        result_ijkl = sot_jm fot_mikl
        
        index = 1, mode=1
        
        result_ijkl = sot_jm fot_imkl
        
        */

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        result = Matrix_9x9::Zero();

        int Ihat;
        int Jhat;
        int Khat;
        int Lhat;

        double tmp;

        if(index == 0){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            tmp = 0;

                            for (int m=0; m<3; m++){
                                Khat = sot_to_voigt_map[m][j];
                                tmp += sot(i,m)*fot(Khat,Jhat);
                            }
                            result(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }
        else if (index == 1){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            tmp = 0;

                            for (int m=0; m<3; m++){
                                Khat = sot_to_voigt_map[j][m];
                                tmp += sot(i,m)*fot(Khat,Jhat);
                            }
                            result(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }
        else if (index == 2){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        Khat = sot_to_voigt_map[j][k];
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            tmp = 0;

                            for (int m=0; m<3; m++){
                                Lhat = sot_to_voigt_map[m][l];
                                tmp += sot(i,m)*fot(Khat,Lhat);
                            }
                            result(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }
        else if (index == 3){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        Khat = sot_to_voigt_map[j][k];
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            tmp = 0;

                            for (int m=0; m<3; m++){
                                Lhat = sot_to_voigt_map[l][m];
                                tmp += sot(i,m)*fot(Khat,Lhat);
                            }
                            result(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }
        else {
            std::cout << "Error: Index out of range\n";
            assert(1==0); //TODO: Replace with better error handling
        }
        if (mode == 1){
            result.row(3).swap(result.row(6));
            result.row(4).swap(result.row(7));
            result.row(5).swap(result.row(8));
        }
        return;
    }

    void dot_2ot_5ot(const int &index, const Matrix_3x3 &sot, const Matrix_9x27 &fot, Matrix_9x27 &result){
        /*!==================
        |    dot_2ot_5ot    |
        =====================
        
        Compute the dot product of a second order tensor and a fifth order tensor at index i+1 i.e.
        
        index = 0
        
        result_ijklm = sot_in fot_njklm
        
        index = 1
        
        result_ijklm = sot_in fot_jnklm
        
        */

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int tot_to_voigt_map[3][3][3];
        get_tot_to_voigt_map(tot_to_voigt_map);
       
        int Ihat;
        int Jhat;
        int Khat;
        int Lhat;

        double tmp;

        if (index == 0){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = tot_to_voigt_map[k][l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = sot_to_voigt_map[n][j];

                                    tmp += sot(i,n)*fot(Lhat,Jhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 1){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = tot_to_voigt_map[k][l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = sot_to_voigt_map[j][n];

                                    tmp += sot(i,n)*fot(Lhat,Jhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 2){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        Khat = sot_to_voigt_map[j][k];
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = tot_to_voigt_map[k][l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = tot_to_voigt_map[n][l][m];

                                    tmp += sot(i,n)*fot(Khat,Lhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 3){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        Khat = sot_to_voigt_map[j][k];
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = tot_to_voigt_map[k][l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = tot_to_voigt_map[l][n][m];

                                    tmp += sot(i,n)*fot(Khat,Lhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 4){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        Khat = sot_to_voigt_map[j][k];
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = tot_to_voigt_map[k][l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = tot_to_voigt_map[l][m][n];

                                    tmp += sot(i,n)*fot(Khat,Lhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else {
            std::cout << "Error: Index out of range\n";
            assert(1==0); //TODO: Replace with better error handling.
        }
        return;  
    }
    
    void dot_2ot_5ot(const int &index, const Matrix_3x3 &sot, const Matrix_27x9 &fot, Matrix_27x9 &result){
        /*!==================
        |    dot_2ot_5ot    |
        =====================
        
        Compute the dot product of a second order tensor and a fifth order tensor at index i+1 i.e.
        
        index = 0
        
        result_ijklm = sot_in fot_njklm
        
        index = 1
        
        result_ijklm = sot_im fot_jnklm
        
        */
    
        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int tot_to_voigt_map[3][3][3];
        get_tot_to_voigt_map(tot_to_voigt_map);
       
        int Ihat;
        int Jhat;
        int Khat;
        int Lhat;

        double tmp;

        if (index == 0){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    for (int k=0; k<3; k++){
                        Ihat = tot_to_voigt_map[i][j][k];
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = sot_to_voigt_map[l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = tot_to_voigt_map[n][j][k];

                                    tmp += sot(i,n)*fot(Lhat,Jhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 1){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    for (int k=0; k<3; k++){
                        Ihat = tot_to_voigt_map[i][j][k];
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = sot_to_voigt_map[l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = tot_to_voigt_map[j][n][k];

                                    tmp += sot(i,n)*fot(Lhat,Jhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 2){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    for (int k=0; k<3; k++){
                        Ihat = tot_to_voigt_map[i][j][k];
                        for (int l=0; l<3; l++){
                            for (int m=0; m<3; m++){
                                Jhat = sot_to_voigt_map[l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = tot_to_voigt_map[j][k][n];

                                    tmp += sot(i,n)*fot(Lhat,Jhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 3){

            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    for (int k=0; k<3; k++){
                        Ihat = tot_to_voigt_map[i][j][k];
                        for (int l=0; l<3; l++){
                            Khat = tot_to_voigt_map[j][k][l];
                            for (int m=0; m<3; m++){
                                Jhat = sot_to_voigt_map[l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = sot_to_voigt_map[n][m];

                                    tmp += sot(i,n)*fot(Khat,Lhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else if (index == 4){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    for (int k=0; k<3; k++){
                        Ihat = tot_to_voigt_map[i][j][k];
                        for (int l=0; l<3; l++){
                            Khat = tot_to_voigt_map[j][k][l];
                            for (int m=0; m<3; m++){
                                Jhat = sot_to_voigt_map[l][m];

                                tmp = 0.;

                                for (int n=0; n<3; n++){
                                    Lhat = sot_to_voigt_map[m][n];

                                    tmp += sot(i,n)*fot(Khat,Lhat);
                                }
                                result(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }
        else {
            std::cout << "Error: Index out of range\n";
            assert(1==0); //TODO: Replace with better error handling.
        }
        return;  
    }
    
    void two_sot_to_fot(const int &swap, const Matrix_3x3 &A, const Matrix_3x3 &B, Matrix_9x9 &C){
        /*!=========================
        |    two_sot_to_fot    |
        ========================
        
        Transform two second order tensors into a fourth order tensor.
        
        i.e.
        
        swap = 0
        C_ijkl = A_ij B_kl
        
        swap = 1
        C_ijkl = A_kj B_il
        
        swap = 2
        C_ijkl = A_il B_kj
        
        */

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int Ihat;
        int Jhat;
        
        double tmp1;

        if (swap == 0){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    tmp1 = A(i,j);
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            C(Ihat,Jhat) = tmp1*B(k,l);
                        }
                    }
                }
            }
        }
        else if (swap == 1){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        tmp1 = A(k,j);
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            C(Ihat,Jhat) = tmp1*B(i,l);
                        }
                    }
                }
            }
        }
        else if (swap == 2){
            for (int i=0; i<3; i++){
                for (int j=0; j<3; j++){
                    Ihat = sot_to_voigt_map[i][j];
                    for (int k=0; k<3; k++){
                        tmp1 = B(k,j);
                        for (int l=0; l<3; l++){
                            Jhat = sot_to_voigt_map[k][l];
                            C(Ihat,Jhat) = A(i,l)*tmp1;
                        }
                    }
                }
            }
        }
        
        return;
    }
    
    void compute_dRCGdF(const Matrix_3x3 &F, SpMat &dRCGdF){
        /*!=====================
        |    compute_dRCGdF    |
        ========================
        
        Compute the derivative of the right 
        cauchy green deformation tensor w.r.t. F.
        
        */
        
        std::vector<T> tripletList;
        tripletList.reserve(45);
        
        //Extract F
        double F11 = F(0,0);
        double F12 = F(0,1);
        double F13 = F(0,2);
        double F21 = F(1,0);
        double F22 = F(1,1);
        double F23 = F(1,2);
        double F31 = F(2,0);
        double F32 = F(2,1);
        double F33 = F(2,2);

        //Assemble dRCGdF
        tripletList.push_back(T(0,0,2*F11));
        tripletList.push_back(T(0,7,2*F31));
        tripletList.push_back(T(0,8,2*F21));
        tripletList.push_back(T(1,1,2*F22));
        tripletList.push_back(T(1,5,2*F12));
        tripletList.push_back(T(1,6,2*F32));
        tripletList.push_back(T(2,2,2*F33));
        tripletList.push_back(T(2,3,2*F23));
        tripletList.push_back(T(2,4,2*F13));
        tripletList.push_back(T(3,1,F23));
        tripletList.push_back(T(3,2,F32));
        tripletList.push_back(T(3,3,F22));
        tripletList.push_back(T(3,4,F12));
        tripletList.push_back(T(3,5,F13));
        tripletList.push_back(T(3,6,F33));
        tripletList.push_back(T(4,0,F13));
        tripletList.push_back(T(4,2,F31));
        tripletList.push_back(T(4,3,F21));
        tripletList.push_back(T(4,4,F11));
        tripletList.push_back(T(4,7,F33));
        tripletList.push_back(T(4,8,F23));
        tripletList.push_back(T(5,0,F12));
        tripletList.push_back(T(5,1,F21));
        tripletList.push_back(T(5,5,F11));
        tripletList.push_back(T(5,6,F31));
        tripletList.push_back(T(5,7,F32));
        tripletList.push_back(T(5,8,F22));
        tripletList.push_back(T(6,1,F23));
        tripletList.push_back(T(6,2,F32));
        tripletList.push_back(T(6,3,F22));
        tripletList.push_back(T(6,4,F12));
        tripletList.push_back(T(6,5,F13));
        tripletList.push_back(T(6,6,F33));
        tripletList.push_back(T(7,0,F13));
        tripletList.push_back(T(7,2,F31));
        tripletList.push_back(T(7,3,F21));
        tripletList.push_back(T(7,4,F11));
        tripletList.push_back(T(7,7,F33));
        tripletList.push_back(T(7,8,F23));
        tripletList.push_back(T(8,0,F12));
        tripletList.push_back(T(8,1,F21));
        tripletList.push_back(T(8,5,F11));
        tripletList.push_back(T(8,6,F31));
        tripletList.push_back(T(8,7,F32));
        tripletList.push_back(T(8,8,F22));      
        
        dRCGdF.setFromTriplets(tripletList.begin(), tripletList.end());        
        
        return;
    }
    
    void compute_dRCGdF(const Matrix_3x3 &F, Matrix_9x9 &dRCGdF){
        /*!=====================
        |    compute_dRCGdF    |
        ========================
        
        Compute the derivative of the right 
        cauchy green deformation tensor w.r.t. F.
        
        */

        double eye[3][3] = {{1,0,0},
                            {0,1,0},
                            {0,0,1}};

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int Ihat;
        int Jhat;

        double tmp1;
        double tmp2;

        for (int I=0; I<3; I++){
            for (int J=0; J<3; J++){
                Ihat = sot_to_voigt_map[I][J];
                for (int k=0; k<3; k++){
                    tmp1 = F(k,J);
                    tmp2 = F(k,I);
                    for (int K=0; K<3; K++){
                        Jhat = sot_to_voigt_map[k][K];
                        dRCGdF(Ihat,Jhat) = tmp1 * eye[I][K] + tmp2 * eye[J][K];
                    }
                }
            }
        }
        return;
    }
    void compute_dPsidF(const Matrix_3x3 &chi, SpMat &dPsidF){
        /*!========================
        |    compute_dPsidF    |
        ========================
        
        Compute the derivative of psi w.r.t. F
        
        */
        
        std::vector<T> tripletList;
        tripletList.reserve(27);

        //Extract chi
        double chi11 = chi(0,0);
        double chi12 = chi(0,1);
        double chi13 = chi(0,2);
        double chi21 = chi(1,0);
        double chi22 = chi(1,1);
        double chi23 = chi(1,2);
        double chi31 = chi(2,0);
        double chi32 = chi(2,1);
        double chi33 = chi(2,2);

        //Assemble dPsidF
        tripletList.push_back(T(0,0,chi11));
        tripletList.push_back(T(0,7,chi31));
        tripletList.push_back(T(0,8,chi21));
        tripletList.push_back(T(1,1,chi22));
        tripletList.push_back(T(1,5,chi12));
        tripletList.push_back(T(1,6,chi32));
        tripletList.push_back(T(2,2,chi33));
        tripletList.push_back(T(2,3,chi23));
        tripletList.push_back(T(2,4,chi13));
        tripletList.push_back(T(3,1,chi23));
        tripletList.push_back(T(3,5,chi13));
        tripletList.push_back(T(3,6,chi33));
        tripletList.push_back(T(4,0,chi13));
        tripletList.push_back(T(4,7,chi33));
        tripletList.push_back(T(4,8,chi23));
        tripletList.push_back(T(5,0,chi12));
        tripletList.push_back(T(5,7,chi32));
        tripletList.push_back(T(5,8,chi22));
        tripletList.push_back(T(6,2,chi32));
        tripletList.push_back(T(6,3,chi22));
        tripletList.push_back(T(6,4,chi12));
        tripletList.push_back(T(7,2,chi31));
        tripletList.push_back(T(7,3,chi21));
        tripletList.push_back(T(7,4,chi11));
        tripletList.push_back(T(8,1,chi21));
        tripletList.push_back(T(8,5,chi11));
        tripletList.push_back(T(8,6,chi31));
        
        dPsidF.setFromTriplets(tripletList.begin(), tripletList.end());        
        
        return;
    }
    
    void compute_dPsidF(const Matrix_3x3 &chi, Matrix_9x9 &dPsidF){
        /*!========================
        |    compute_dPsidF    |
        ========================
        
        Compute the derivative of psi w.r.t. F
        
        */

        dPsidF = Matrix_9x9::Zero();

        dPsidF( 0, 0) = chi(0,0);
        dPsidF( 0, 7) = chi(2,0);
        dPsidF( 0, 8) = chi(1,0);
        dPsidF( 1, 1) = chi(1,1);
        dPsidF( 1, 5) = chi(0,1);
        dPsidF( 1, 6) = chi(2,1);
        dPsidF( 2, 2) = chi(2,2);
        dPsidF( 2, 3) = chi(1,2);
        dPsidF( 2, 4) = chi(0,2);
        dPsidF( 3, 1) = chi(1,2);
        dPsidF( 3, 5) = chi(0,2);
        dPsidF( 3, 6) = chi(2,2);
        dPsidF( 4, 0) = chi(0,2);
        dPsidF( 4, 7) = chi(2,2);
        dPsidF( 4, 8) = chi(1,2);
        dPsidF( 5, 0) = chi(0,1);
        dPsidF( 5, 7) = chi(2,1);
        dPsidF( 5, 8) = chi(1,1);
        dPsidF( 6, 2) = chi(2,1);
        dPsidF( 6, 3) = chi(1,1);
        dPsidF( 6, 4) = chi(0,1);
        dPsidF( 7, 2) = chi(2,0);
        dPsidF( 7, 3) = chi(1,0);
        dPsidF( 7, 4) = chi(0,0);
        dPsidF( 8, 1) = chi(1,0);
        dPsidF( 8, 5) = chi(0,0);
        dPsidF( 8, 6) = chi(2,0);

        return;
    }

    void compute_dGammadF(const Vector_27 &grad_chi, SpMat &dGammadF){
        /*!==========================
        |    compute_dGammadF    |
        ==========================
        
        Compute the derivative of gamma w.r.t. F.
        
        */
        
        //Initialize the tripletList
        std::vector<T> tripletList;
        tripletList.reserve(81);

        //Extract grad_chi
        double grad_chi111 = grad_chi(0);
        double grad_chi122 = grad_chi(1);
        double grad_chi133 = grad_chi(2);
        double grad_chi123 = grad_chi(3);
        double grad_chi113 = grad_chi(4);
        double grad_chi112 = grad_chi(5);
        double grad_chi132 = grad_chi(6);
        double grad_chi131 = grad_chi(7);
        double grad_chi121 = grad_chi(8);
        double grad_chi211 = grad_chi(9);
        double grad_chi222 = grad_chi(10);
        double grad_chi233 = grad_chi(11);
        double grad_chi223 = grad_chi(12);
        double grad_chi213 = grad_chi(13);
        double grad_chi212 = grad_chi(14);
        double grad_chi232 = grad_chi(15);
        double grad_chi231 = grad_chi(16);
        double grad_chi221 = grad_chi(17);
        double grad_chi311 = grad_chi(18);
        double grad_chi322 = grad_chi(19);
        double grad_chi333 = grad_chi(20);
        double grad_chi323 = grad_chi(21);
        double grad_chi313 = grad_chi(22);
        double grad_chi312 = grad_chi(23);
        double grad_chi332 = grad_chi(24);
        double grad_chi331 = grad_chi(25);
        double grad_chi321 = grad_chi(26);

         //Assemble dGammadF
        tripletList.push_back(T(0,0,grad_chi111));
        tripletList.push_back(T(0,7,grad_chi311));
        tripletList.push_back(T(0,8,grad_chi211));
        tripletList.push_back(T(1,0,grad_chi122));
        tripletList.push_back(T(1,7,grad_chi322));
        tripletList.push_back(T(1,8,grad_chi222));
        tripletList.push_back(T(2,0,grad_chi133));
        tripletList.push_back(T(2,7,grad_chi333));
        tripletList.push_back(T(2,8,grad_chi233));
        tripletList.push_back(T(3,0,grad_chi123));
        tripletList.push_back(T(3,7,grad_chi323));
        tripletList.push_back(T(3,8,grad_chi223));
        tripletList.push_back(T(4,0,grad_chi113));
        tripletList.push_back(T(4,7,grad_chi313));
        tripletList.push_back(T(4,8,grad_chi213));
        tripletList.push_back(T(5,0,grad_chi112));
        tripletList.push_back(T(5,7,grad_chi312));
        tripletList.push_back(T(5,8,grad_chi212));
        tripletList.push_back(T(6,0,grad_chi132));
        tripletList.push_back(T(6,7,grad_chi332));
        tripletList.push_back(T(6,8,grad_chi232));
        tripletList.push_back(T(7,0,grad_chi131));
        tripletList.push_back(T(7,7,grad_chi331));
        tripletList.push_back(T(7,8,grad_chi231));
        tripletList.push_back(T(8,0,grad_chi121));
        tripletList.push_back(T(8,7,grad_chi321));
        tripletList.push_back(T(8,8,grad_chi221));
        tripletList.push_back(T(9,1,grad_chi211));
        tripletList.push_back(T(9,5,grad_chi111));
        tripletList.push_back(T(9,6,grad_chi311));
        tripletList.push_back(T(10,1,grad_chi222));
        tripletList.push_back(T(10,5,grad_chi122));
        tripletList.push_back(T(10,6,grad_chi322));
        tripletList.push_back(T(11,1,grad_chi233));
        tripletList.push_back(T(11,5,grad_chi133));
        tripletList.push_back(T(11,6,grad_chi333));
        tripletList.push_back(T(12,1,grad_chi223));
        tripletList.push_back(T(12,5,grad_chi123));
        tripletList.push_back(T(12,6,grad_chi323));
        tripletList.push_back(T(13,1,grad_chi213));
        tripletList.push_back(T(13,5,grad_chi113));
        tripletList.push_back(T(13,6,grad_chi313));
        tripletList.push_back(T(14,1,grad_chi212));
        tripletList.push_back(T(14,5,grad_chi112));
        tripletList.push_back(T(14,6,grad_chi312));
        tripletList.push_back(T(15,1,grad_chi232));
        tripletList.push_back(T(15,5,grad_chi132));
        tripletList.push_back(T(15,6,grad_chi332));
        tripletList.push_back(T(16,1,grad_chi231));
        tripletList.push_back(T(16,5,grad_chi131));
        tripletList.push_back(T(16,6,grad_chi331));
        tripletList.push_back(T(17,1,grad_chi221));
        tripletList.push_back(T(17,5,grad_chi121));
        tripletList.push_back(T(17,6,grad_chi321));
        tripletList.push_back(T(18,2,grad_chi311));
        tripletList.push_back(T(18,3,grad_chi211));
        tripletList.push_back(T(18,4,grad_chi111));
        tripletList.push_back(T(19,2,grad_chi322));
        tripletList.push_back(T(19,3,grad_chi222));
        tripletList.push_back(T(19,4,grad_chi122));
        tripletList.push_back(T(20,2,grad_chi333));
        tripletList.push_back(T(20,3,grad_chi233));
        tripletList.push_back(T(20,4,grad_chi133));
        tripletList.push_back(T(21,2,grad_chi323));
        tripletList.push_back(T(21,3,grad_chi223));
        tripletList.push_back(T(21,4,grad_chi123));
        tripletList.push_back(T(22,2,grad_chi313));
        tripletList.push_back(T(22,3,grad_chi213));
        tripletList.push_back(T(22,4,grad_chi113));
        tripletList.push_back(T(23,2,grad_chi312));
        tripletList.push_back(T(23,3,grad_chi212));
        tripletList.push_back(T(23,4,grad_chi112));
        tripletList.push_back(T(24,2,grad_chi332));
        tripletList.push_back(T(24,3,grad_chi232));
        tripletList.push_back(T(24,4,grad_chi132));
        tripletList.push_back(T(25,2,grad_chi331));
        tripletList.push_back(T(25,3,grad_chi231));
        tripletList.push_back(T(25,4,grad_chi131));
        tripletList.push_back(T(26,2,grad_chi321));
        tripletList.push_back(T(26,3,grad_chi221));
        tripletList.push_back(T(26,4,grad_chi121));
        
        dGammadF.setFromTriplets(tripletList.begin(), tripletList.end());
        return;
    }


    void compute_dGammadF(const Vector_27 &grad_chi, Matrix_27x9 &dGammadF){
        /*!==========================
        |    compute_dGammadF    |
        ==========================
        
        Compute the derivative of gamma w.r.t. F.
        
        */

        dGammadF = Matrix_27x9::Zero();

        dGammadF(0,0) = grad_chi(0,0);
        dGammadF(0,7) = grad_chi(18,0);
        dGammadF(0,8) = grad_chi(9,0);
        dGammadF(1,0) = grad_chi(1,0);
        dGammadF(1,7) = grad_chi(19,0);
        dGammadF(1,8) = grad_chi(10,0);
        dGammadF(2,0) = grad_chi(2,0);
        dGammadF(2,7) = grad_chi(20,0);
        dGammadF(2,8) = grad_chi(11,0);
        dGammadF(3,0) = grad_chi(3,0);
        dGammadF(3,7) = grad_chi(21,0);
        dGammadF(3,8) = grad_chi(12,0);
        dGammadF(4,0) = grad_chi(4,0);
        dGammadF(4,7) = grad_chi(22,0);
        dGammadF(4,8) = grad_chi(13,0);
        dGammadF(5,0) = grad_chi(5,0);
        dGammadF(5,7) = grad_chi(23,0);
        dGammadF(5,8) = grad_chi(14,0);
        dGammadF(6,0) = grad_chi(6,0);
        dGammadF(6,7) = grad_chi(24,0);
        dGammadF(6,8) = grad_chi(15,0);
        dGammadF(7,0) = grad_chi(7,0);
        dGammadF(7,7) = grad_chi(25,0);
        dGammadF(7,8) = grad_chi(16,0);
        dGammadF(8,0) = grad_chi(8,0);
        dGammadF(8,7) = grad_chi(26,0);
        dGammadF(8,8) = grad_chi(17,0);
        dGammadF(9,1) = grad_chi(9,0);
        dGammadF(9,5) = grad_chi(0,0);
        dGammadF(9,6) = grad_chi(18,0);
        dGammadF(10,1) = grad_chi(10,0);
        dGammadF(10,5) = grad_chi(1,0);
        dGammadF(10,6) = grad_chi(19,0);
        dGammadF(11,1) = grad_chi(11,0);
        dGammadF(11,5) = grad_chi(2,0);
        dGammadF(11,6) = grad_chi(20,0);
        dGammadF(12,1) = grad_chi(12,0);
        dGammadF(12,5) = grad_chi(3,0);
        dGammadF(12,6) = grad_chi(21,0);
        dGammadF(13,1) = grad_chi(13,0);
        dGammadF(13,5) = grad_chi(4,0);
        dGammadF(13,6) = grad_chi(22,0);
        dGammadF(14,1) = grad_chi(14,0);
        dGammadF(14,5) = grad_chi(5,0);
        dGammadF(14,6) = grad_chi(23,0);
        dGammadF(15,1) = grad_chi(15,0);
        dGammadF(15,5) = grad_chi(6,0);
        dGammadF(15,6) = grad_chi(24,0);
        dGammadF(16,1) = grad_chi(16,0);
        dGammadF(16,5) = grad_chi(7,0);
        dGammadF(16,6) = grad_chi(25,0);
        dGammadF(17,1) = grad_chi(17,0);
        dGammadF(17,5) = grad_chi(8,0);
        dGammadF(17,6) = grad_chi(26,0);
        dGammadF(18,2) = grad_chi(18,0);
        dGammadF(18,3) = grad_chi(9,0);
        dGammadF(18,4) = grad_chi(0,0);
        dGammadF(19,2) = grad_chi(19,0);
        dGammadF(19,3) = grad_chi(10,0);
        dGammadF(19,4) = grad_chi(1,0);
        dGammadF(20,2) = grad_chi(20,0);
        dGammadF(20,3) = grad_chi(11,0);
        dGammadF(20,4) = grad_chi(2,0);
        dGammadF(21,2) = grad_chi(21,0);
        dGammadF(21,3) = grad_chi(12,0);
        dGammadF(21,4) = grad_chi(3,0);
        dGammadF(22,2) = grad_chi(22,0);
        dGammadF(22,3) = grad_chi(13,0);
        dGammadF(22,4) = grad_chi(4,0);
        dGammadF(23,2) = grad_chi(23,0);
        dGammadF(23,3) = grad_chi(14,0);
        dGammadF(23,4) = grad_chi(5,0);
        dGammadF(24,2) = grad_chi(24,0);
        dGammadF(24,3) = grad_chi(15,0);
        dGammadF(24,4) = grad_chi(6,0);
        dGammadF(25,2) = grad_chi(25,0);
        dGammadF(25,3) = grad_chi(16,0);
        dGammadF(25,4) = grad_chi(7,0);
        dGammadF(26,2) = grad_chi(26,0);
        dGammadF(26,3) = grad_chi(17,0);
        dGammadF(26,4) = grad_chi(8,0);        

        return;
    }
    
    void compute_dPsidchi(const Matrix_3x3 &F, SpMat &dPsidchi){
        /*!==========================
        |    compute_dPsidchi    |
        ==========================
        
        Compute the derivative of Psi with respect to chi.
        
        */
        
        //Initialize the tripletList
        std::vector<T> tripletList;
        tripletList.reserve(27);

        //Extract F
        double F11 = F(0,0);
        double F12 = F(0,1);
        double F13 = F(0,2);
        double F21 = F(1,0);
        double F22 = F(1,1);
        double F23 = F(1,2);
        double F31 = F(2,0);
        double F32 = F(2,1);
        double F33 = F(2,2);

        //Assemble dPsidchi
        tripletList.push_back(T(0,0,F11));
        tripletList.push_back(T(0,7,F31));
        tripletList.push_back(T(0,8,F21));
        tripletList.push_back(T(1,1,F22));
        tripletList.push_back(T(1,5,F12));
        tripletList.push_back(T(1,6,F32));
        tripletList.push_back(T(2,2,F33));
        tripletList.push_back(T(2,3,F23));
        tripletList.push_back(T(2,4,F13));
        tripletList.push_back(T(3,2,F32));
        tripletList.push_back(T(3,3,F22));
        tripletList.push_back(T(3,4,F12));
        tripletList.push_back(T(4,2,F31));
        tripletList.push_back(T(4,3,F21));
        tripletList.push_back(T(4,4,F11));
        tripletList.push_back(T(5,1,F21));
        tripletList.push_back(T(5,5,F11));
        tripletList.push_back(T(5,6,F31));
        tripletList.push_back(T(6,1,F23));
        tripletList.push_back(T(6,5,F13));
        tripletList.push_back(T(6,6,F33));
        tripletList.push_back(T(7,0,F13));
        tripletList.push_back(T(7,7,F33));
        tripletList.push_back(T(7,8,F23));
        tripletList.push_back(T(8,0,F12));
        tripletList.push_back(T(8,7,F32));
        tripletList.push_back(T(8,8,F22));
        
        dPsidchi.setFromTriplets(tripletList.begin(), tripletList.end());
        return;
    }
    
    void compute_dPsidchi(const Matrix_3x3 &F, Matrix_9x9 &dPsidchi){
        /*!==========================
        |    compute_dPsidchi    |
        ==========================
        
        Compute the derivative of Psi with respect to chi.
        
        */

        dPsidchi = Matrix_9x9::Zero();

        dPsidchi(0,0) = F(0,0);
        dPsidchi(0,7) = F(2,0);
        dPsidchi(0,8) = F(1,0);
        dPsidchi(1,1) = F(1,1);
        dPsidchi(1,5) = F(0,1);
        dPsidchi(1,6) = F(2,1);
        dPsidchi(2,2) = F(2,2);
        dPsidchi(2,3) = F(1,2);
        dPsidchi(2,4) = F(0,2);
        dPsidchi(3,2) = F(2,1);
        dPsidchi(3,3) = F(1,1);
        dPsidchi(3,4) = F(0,1);
        dPsidchi(4,2) = F(2,0);
        dPsidchi(4,3) = F(1,0);
        dPsidchi(4,4) = F(0,0);
        dPsidchi(5,1) = F(1,0);
        dPsidchi(5,5) = F(0,0);
        dPsidchi(5,6) = F(2,0);
        dPsidchi(6,1) = F(1,2);
        dPsidchi(6,5) = F(0,2);
        dPsidchi(6,6) = F(2,2);
        dPsidchi(7,0) = F(0,2);
        dPsidchi(7,7) = F(2,2);
        dPsidchi(7,8) = F(1,2);
        dPsidchi(8,0) = F(0,1);
        dPsidchi(8,7) = F(2,1);
        dPsidchi(8,8) = F(1,1);

        return;
    }

    void compute_dGammadgrad_chi(const Matrix_3x3 &F, SpMat &dGammadgrad_chi){
        /*!=================================
        |    compute_dGammadgrad_chi    |
        =================================
        
        Computes the gradient of gamma w.r.t. the gradient 
        of chi.
        
        NOTE: The gradient of chi is assumed to be in the reference
              configuration. This means Gamma is defined as
              
              Gamma_IJK = F_iI chi_iJ,K
        */
        
        //Initialize the tripletList
        std::vector<T> tripletList;
        tripletList.reserve(81);

        //Extract F
        double F11 = F(0,0);
        double F12 = F(0,1);
        double F13 = F(0,2);
        double F21 = F(1,0);
        double F22 = F(1,1);
        double F23 = F(1,2);
        double F31 = F(2,0);
        double F32 = F(2,1);
        double F33 = F(2,2);

        //Assemble dGammadgrad_chi
        tripletList.push_back(T(0,0,F11));
        tripletList.push_back(T(0,9,F21));
        tripletList.push_back(T(0,18,F31));
        tripletList.push_back(T(1,1,F11));
        tripletList.push_back(T(1,10,F21));
        tripletList.push_back(T(1,19,F31));
        tripletList.push_back(T(2,2,F11));
        tripletList.push_back(T(2,11,F21));
        tripletList.push_back(T(2,20,F31));
        tripletList.push_back(T(3,3,F11));
        tripletList.push_back(T(3,12,F21));
        tripletList.push_back(T(3,21,F31));
        tripletList.push_back(T(4,4,F11));
        tripletList.push_back(T(4,13,F21));
        tripletList.push_back(T(4,22,F31));
        tripletList.push_back(T(5,5,F11));
        tripletList.push_back(T(5,14,F21));
        tripletList.push_back(T(5,23,F31));
        tripletList.push_back(T(6,6,F11));
        tripletList.push_back(T(6,15,F21));
        tripletList.push_back(T(6,24,F31));
        tripletList.push_back(T(7,7,F11));
        tripletList.push_back(T(7,16,F21));
        tripletList.push_back(T(7,25,F31));
        tripletList.push_back(T(8,8,F11));
        tripletList.push_back(T(8,17,F21));
        tripletList.push_back(T(8,26,F31));
        tripletList.push_back(T(9,0,F12));
        tripletList.push_back(T(9,9,F22));
        tripletList.push_back(T(9,18,F32));
        tripletList.push_back(T(10,1,F12));
        tripletList.push_back(T(10,10,F22));
        tripletList.push_back(T(10,19,F32));
        tripletList.push_back(T(11,2,F12));
        tripletList.push_back(T(11,11,F22));
        tripletList.push_back(T(11,20,F32));
        tripletList.push_back(T(12,3,F12));
        tripletList.push_back(T(12,12,F22));
        tripletList.push_back(T(12,21,F32));
        tripletList.push_back(T(13,4,F12));
        tripletList.push_back(T(13,13,F22));
        tripletList.push_back(T(13,22,F32));
        tripletList.push_back(T(14,5,F12));
        tripletList.push_back(T(14,14,F22));
        tripletList.push_back(T(14,23,F32));
        tripletList.push_back(T(15,6,F12));
        tripletList.push_back(T(15,15,F22));
        tripletList.push_back(T(15,24,F32));
        tripletList.push_back(T(16,7,F12));
        tripletList.push_back(T(16,16,F22));
        tripletList.push_back(T(16,25,F32));
        tripletList.push_back(T(17,8,F12));
        tripletList.push_back(T(17,17,F22));
        tripletList.push_back(T(17,26,F32));
        tripletList.push_back(T(18,0,F13));
        tripletList.push_back(T(18,9,F23));
        tripletList.push_back(T(18,18,F33));
        tripletList.push_back(T(19,1,F13));
        tripletList.push_back(T(19,10,F23));
        tripletList.push_back(T(19,19,F33));
        tripletList.push_back(T(20,2,F13));
        tripletList.push_back(T(20,11,F23));
        tripletList.push_back(T(20,20,F33));
        tripletList.push_back(T(21,3,F13));
        tripletList.push_back(T(21,12,F23));
        tripletList.push_back(T(21,21,F33));
        tripletList.push_back(T(22,4,F13));
        tripletList.push_back(T(22,13,F23));
        tripletList.push_back(T(22,22,F33));
        tripletList.push_back(T(23,5,F13));
        tripletList.push_back(T(23,14,F23));
        tripletList.push_back(T(23,23,F33));
        tripletList.push_back(T(24,6,F13));
        tripletList.push_back(T(24,15,F23));
        tripletList.push_back(T(24,24,F33));
        tripletList.push_back(T(25,7,F13));
        tripletList.push_back(T(25,16,F23));
        tripletList.push_back(T(25,25,F33));
        tripletList.push_back(T(26,8,F13));
        tripletList.push_back(T(26,17,F23));
        tripletList.push_back(T(26,26,F33));
        
        dGammadgrad_chi.setFromTriplets(tripletList.begin(), tripletList.end());
        return;
    }
    
    void compute_dGammadgrad_chi(const Matrix_3x3 &F, Matrix_27x27 &dGammadgrad_chi){
        /*!=================================
        |    compute_dGammadgrad_chi    |
        =================================
        
        Computes the gradient of gamma w.r.t. the gradient 
        of chi.
        
        NOTE: The gradient of chi is assumed to be in the reference
              configuration. This means Gamma is defined as
              
              Gamma_IJK = F_iI chi_iJ,K
        */

        dGammadgrad_chi = Matrix_27x27::Zero();

        dGammadgrad_chi(0,0) = F(0,0);
        dGammadgrad_chi(0,9) = F(1,0);
        dGammadgrad_chi(0,18) = F(2,0);
        dGammadgrad_chi(1,1) = F(0,0);
        dGammadgrad_chi(1,10) = F(1,0);
        dGammadgrad_chi(1,19) = F(2,0);
        dGammadgrad_chi(2,2) = F(0,0);
        dGammadgrad_chi(2,11) = F(1,0);
        dGammadgrad_chi(2,20) = F(2,0);
        dGammadgrad_chi(3,3) = F(0,0);
        dGammadgrad_chi(3,12) = F(1,0);
        dGammadgrad_chi(3,21) = F(2,0);
        dGammadgrad_chi(4,4) = F(0,0);
        dGammadgrad_chi(4,13) = F(1,0);
        dGammadgrad_chi(4,22) = F(2,0);
        dGammadgrad_chi(5,5) = F(0,0);
        dGammadgrad_chi(5,14) = F(1,0);
        dGammadgrad_chi(5,23) = F(2,0);
        dGammadgrad_chi(6,6) = F(0,0);
        dGammadgrad_chi(6,15) = F(1,0);
        dGammadgrad_chi(6,24) = F(2,0);
        dGammadgrad_chi(7,7) = F(0,0);
        dGammadgrad_chi(7,16) = F(1,0);
        dGammadgrad_chi(7,25) = F(2,0);
        dGammadgrad_chi(8,8) = F(0,0);
        dGammadgrad_chi(8,17) = F(1,0);
        dGammadgrad_chi(8,26) = F(2,0);
        dGammadgrad_chi(9,0) = F(0,1);
        dGammadgrad_chi(9,9) = F(1,1);
        dGammadgrad_chi(9,18) = F(2,1);
        dGammadgrad_chi(10,1) = F(0,1);
        dGammadgrad_chi(10,10) = F(1,1);
        dGammadgrad_chi(10,19) = F(2,1);
        dGammadgrad_chi(11,2) = F(0,1);
        dGammadgrad_chi(11,11) = F(1,1);
        dGammadgrad_chi(11,20) = F(2,1);
        dGammadgrad_chi(12,3) = F(0,1);
        dGammadgrad_chi(12,12) = F(1,1);
        dGammadgrad_chi(12,21) = F(2,1);
        dGammadgrad_chi(13,4) = F(0,1);
        dGammadgrad_chi(13,13) = F(1,1);
        dGammadgrad_chi(13,22) = F(2,1);
        dGammadgrad_chi(14,5) = F(0,1);
        dGammadgrad_chi(14,14) = F(1,1);
        dGammadgrad_chi(14,23) = F(2,1);
        dGammadgrad_chi(15,6) = F(0,1);
        dGammadgrad_chi(15,15) = F(1,1);
        dGammadgrad_chi(15,24) = F(2,1);
        dGammadgrad_chi(16,7) = F(0,1);
        dGammadgrad_chi(16,16) = F(1,1);
        dGammadgrad_chi(16,25) = F(2,1);
        dGammadgrad_chi(17,8) = F(0,1);
        dGammadgrad_chi(17,17) = F(1,1);
        dGammadgrad_chi(17,26) = F(2,1);
        dGammadgrad_chi(18,0) = F(0,2);
        dGammadgrad_chi(18,9) = F(1,2);
        dGammadgrad_chi(18,18) = F(2,2);
        dGammadgrad_chi(19,1) = F(0,2);
        dGammadgrad_chi(19,10) = F(1,2);
        dGammadgrad_chi(19,19) = F(2,2);
        dGammadgrad_chi(20,2) = F(0,2);
        dGammadgrad_chi(20,11) = F(1,2);
        dGammadgrad_chi(20,20) = F(2,2);
        dGammadgrad_chi(21,3) = F(0,2);
        dGammadgrad_chi(21,12) = F(1,2);
        dGammadgrad_chi(21,21) = F(2,2);
        dGammadgrad_chi(22,4) = F(0,2);
        dGammadgrad_chi(22,13) = F(1,2);
        dGammadgrad_chi(22,22) = F(2,2);
        dGammadgrad_chi(23,5) = F(0,2);
        dGammadgrad_chi(23,14) = F(1,2);
        dGammadgrad_chi(23,23) = F(2,2);
        dGammadgrad_chi(24,6) = F(0,2);
        dGammadgrad_chi(24,15) = F(1,2);
        dGammadgrad_chi(24,24) = F(2,2);
        dGammadgrad_chi(25,7) = F(0,2);
        dGammadgrad_chi(25,16) = F(1,2);
        dGammadgrad_chi(25,25) = F(2,2);
        dGammadgrad_chi(26,8) = F(0,2);
        dGammadgrad_chi(26,17) = F(1,2);
        dGammadgrad_chi(26,26) = F(2,2);

        return;
    }

    void compute_dAinvdA(const Matrix_3x3 &Ainv, Matrix_9x9 &dAinvdA){
        /*!=========================
        |    compute_dAinvdA    |
        =========================
        
        Compute the derivative of the inverse of a second order tensor w.r.t. the tensor.
        
        */

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int Ihat;
        int Jhat;
        
        double tmp1;
        
        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                Ihat = sot_to_voigt_map[i][j];
                for (int k=0; k<3; k++){
                    tmp1 = Ainv(i,k);
                    for (int l=0; l<3; l++){
                        Jhat = sot_to_voigt_map[k][l];
                        dAinvdA(Ihat,Jhat) = -tmp1*Ainv(l,j);
                    }
                }
            }
        }
        return;
    }
    
    void compute_dgrad_chidgrad_phi(const Matrix_3x3 &F, SpMat &dgrad_chidgrad_phi){
        /*!====================================
        |    compute_dgrad_chidgrad_phi    |
        ====================================
        
        Compute the gradient of the gradient of chi w.r.t. the gradient of phi.
        
        Note: We assume that grad_phi is a gradient of phi in the current configuration.
        
        */
        
        //Initialize the tripletList
        std::vector<T> tripletList;
        tripletList.reserve(81);

        //Extract F
        double F11 = F(0,0);
        double F12 = F(0,1);
        double F13 = F(0,2);
        double F21 = F(1,0);
        double F22 = F(1,1);
        double F23 = F(1,2);
        double F31 = F(2,0);
        double F32 = F(2,1);
        double F33 = F(2,2);

        //Assemble dgrad_chidgrad_phi
        tripletList.push_back(T(0,0,F11));
        tripletList.push_back(T(0,4,F31));
        tripletList.push_back(T(0,5,F21));
        tripletList.push_back(T(1,1,F22));
        tripletList.push_back(T(1,3,F32));
        tripletList.push_back(T(1,8,F12));
        tripletList.push_back(T(2,2,F33));
        tripletList.push_back(T(2,6,F23));
        tripletList.push_back(T(2,7,F13));
        tripletList.push_back(T(3,1,F23));
        tripletList.push_back(T(3,3,F33));
        tripletList.push_back(T(3,8,F13));
        tripletList.push_back(T(4,0,F13));
        tripletList.push_back(T(4,4,F33));
        tripletList.push_back(T(4,5,F23));
        tripletList.push_back(T(5,0,F12));
        tripletList.push_back(T(5,4,F32));
        tripletList.push_back(T(5,5,F22));
        tripletList.push_back(T(6,2,F32));
        tripletList.push_back(T(6,6,F22));
        tripletList.push_back(T(6,7,F12));
        tripletList.push_back(T(7,2,F31));
        tripletList.push_back(T(7,6,F21));
        tripletList.push_back(T(7,7,F11));
        tripletList.push_back(T(8,1,F21));
        tripletList.push_back(T(8,3,F31));
        tripletList.push_back(T(8,8,F11));
        tripletList.push_back(T(9,9,F11));
        tripletList.push_back(T(9,13,F31));
        tripletList.push_back(T(9,14,F21));
        tripletList.push_back(T(10,10,F22));
        tripletList.push_back(T(10,12,F32));
        tripletList.push_back(T(10,17,F12));
        tripletList.push_back(T(11,11,F33));
        tripletList.push_back(T(11,15,F23));
        tripletList.push_back(T(11,16,F13));
        tripletList.push_back(T(12,10,F23));
        tripletList.push_back(T(12,12,F33));
        tripletList.push_back(T(12,17,F13));
        tripletList.push_back(T(13,9,F13));
        tripletList.push_back(T(13,13,F33));
        tripletList.push_back(T(13,14,F23));
        tripletList.push_back(T(14,9,F12));
        tripletList.push_back(T(14,13,F32));
        tripletList.push_back(T(14,14,F22));
        tripletList.push_back(T(15,11,F32));
        tripletList.push_back(T(15,15,F22));
        tripletList.push_back(T(15,16,F12));
        tripletList.push_back(T(16,11,F31));
        tripletList.push_back(T(16,15,F21));
        tripletList.push_back(T(16,16,F11));
        tripletList.push_back(T(17,10,F21));
        tripletList.push_back(T(17,12,F31));
        tripletList.push_back(T(17,17,F11));
        tripletList.push_back(T(18,18,F11));
        tripletList.push_back(T(18,22,F31));
        tripletList.push_back(T(18,23,F21));
        tripletList.push_back(T(19,19,F22));
        tripletList.push_back(T(19,21,F32));
        tripletList.push_back(T(19,26,F12));
        tripletList.push_back(T(20,20,F33));
        tripletList.push_back(T(20,24,F23));
        tripletList.push_back(T(20,25,F13));
        tripletList.push_back(T(21,19,F23));
        tripletList.push_back(T(21,21,F33));
        tripletList.push_back(T(21,26,F13));
        tripletList.push_back(T(22,18,F13));
        tripletList.push_back(T(22,22,F33));
        tripletList.push_back(T(22,23,F23));
        tripletList.push_back(T(23,18,F12));
        tripletList.push_back(T(23,22,F32));
        tripletList.push_back(T(23,23,F22));
        tripletList.push_back(T(24,20,F32));
        tripletList.push_back(T(24,24,F22));
        tripletList.push_back(T(24,25,F12));
        tripletList.push_back(T(25,20,F31));
        tripletList.push_back(T(25,24,F21));
        tripletList.push_back(T(25,25,F11));
        tripletList.push_back(T(26,19,F21));
        tripletList.push_back(T(26,21,F31));
        tripletList.push_back(T(26,26,F11));
        
        dgrad_chidgrad_phi.setFromTriplets(tripletList.begin(), tripletList.end());
        return;
    }
    
    void compute_dgrad_chidgrad_phi(const Matrix_3x3 &F, Matrix_27x27 &dgrad_chidgrad_phi){
        /*!====================================
        |    compute_dgrad_chidgrad_phi    |
        ====================================
        
        Compute the gradient of the gradient of chi w.r.t. the gradient of phi.
        
        Note: We assume that grad_phi is a gradient of phi in the current configuration.
        
        */

        dgrad_chidgrad_phi = Matrix_27x27::Zero();

        dgrad_chidgrad_phi(0,0) = F(0,0);
        dgrad_chidgrad_phi(0,4) = F(2,0);
        dgrad_chidgrad_phi(0,5) = F(1,0);
        dgrad_chidgrad_phi(1,1) = F(1,1);
        dgrad_chidgrad_phi(1,3) = F(2,1);
        dgrad_chidgrad_phi(1,8) = F(0,1);
        dgrad_chidgrad_phi(2,2) = F(2,2);
        dgrad_chidgrad_phi(2,6) = F(1,2);
        dgrad_chidgrad_phi(2,7) = F(0,2);
        dgrad_chidgrad_phi(3,1) = F(1,2);
        dgrad_chidgrad_phi(3,3) = F(2,2);
        dgrad_chidgrad_phi(3,8) = F(0,2);
        dgrad_chidgrad_phi(4,0) = F(0,2);
        dgrad_chidgrad_phi(4,4) = F(2,2);
        dgrad_chidgrad_phi(4,5) = F(1,2);
        dgrad_chidgrad_phi(5,0) = F(0,1);
        dgrad_chidgrad_phi(5,4) = F(2,1);
        dgrad_chidgrad_phi(5,5) = F(1,1);
        dgrad_chidgrad_phi(6,2) = F(2,1);
        dgrad_chidgrad_phi(6,6) = F(1,1);
        dgrad_chidgrad_phi(6,7) = F(0,1);
        dgrad_chidgrad_phi(7,2) = F(2,0);
        dgrad_chidgrad_phi(7,6) = F(1,0);
        dgrad_chidgrad_phi(7,7) = F(0,0);
        dgrad_chidgrad_phi(8,1) = F(1,0);
        dgrad_chidgrad_phi(8,3) = F(2,0);
        dgrad_chidgrad_phi(8,8) = F(0,0);
        dgrad_chidgrad_phi(9,9) = F(0,0);
        dgrad_chidgrad_phi(9,13) = F(2,0);
        dgrad_chidgrad_phi(9,14) = F(1,0);
        dgrad_chidgrad_phi(10,10) = F(1,1);
        dgrad_chidgrad_phi(10,12) = F(2,1);
        dgrad_chidgrad_phi(10,17) = F(0,1);
        dgrad_chidgrad_phi(11,11) = F(2,2);
        dgrad_chidgrad_phi(11,15) = F(1,2);
        dgrad_chidgrad_phi(11,16) = F(0,2);
        dgrad_chidgrad_phi(12,10) = F(1,2);
        dgrad_chidgrad_phi(12,12) = F(2,2);
        dgrad_chidgrad_phi(12,17) = F(0,2);
        dgrad_chidgrad_phi(13,9) = F(0,2);
        dgrad_chidgrad_phi(13,13) = F(2,2);
        dgrad_chidgrad_phi(13,14) = F(1,2);
        dgrad_chidgrad_phi(14,9) = F(0,1);
        dgrad_chidgrad_phi(14,13) = F(2,1);
        dgrad_chidgrad_phi(14,14) = F(1,1);
        dgrad_chidgrad_phi(15,11) = F(2,1);
        dgrad_chidgrad_phi(15,15) = F(1,1);
        dgrad_chidgrad_phi(15,16) = F(0,1);
        dgrad_chidgrad_phi(16,11) = F(2,0);
        dgrad_chidgrad_phi(16,15) = F(1,0);
        dgrad_chidgrad_phi(16,16) = F(0,0);
        dgrad_chidgrad_phi(17,10) = F(1,0);
        dgrad_chidgrad_phi(17,12) = F(2,0);
        dgrad_chidgrad_phi(17,17) = F(0,0);
        dgrad_chidgrad_phi(18,18) = F(0,0);
        dgrad_chidgrad_phi(18,22) = F(2,0);
        dgrad_chidgrad_phi(18,23) = F(1,0);
        dgrad_chidgrad_phi(19,19) = F(1,1);
        dgrad_chidgrad_phi(19,21) = F(2,1);
        dgrad_chidgrad_phi(19,26) = F(0,1);
        dgrad_chidgrad_phi(20,20) = F(2,2);
        dgrad_chidgrad_phi(20,24) = F(1,2);
        dgrad_chidgrad_phi(20,25) = F(0,2);
        dgrad_chidgrad_phi(21,19) = F(1,2);
        dgrad_chidgrad_phi(21,21) = F(2,2);
        dgrad_chidgrad_phi(21,26) = F(0,2);
        dgrad_chidgrad_phi(22,18) = F(0,2);
        dgrad_chidgrad_phi(22,22) = F(2,2);
        dgrad_chidgrad_phi(22,23) = F(1,2);
        dgrad_chidgrad_phi(23,18) = F(0,1);
        dgrad_chidgrad_phi(23,22) = F(2,1);
        dgrad_chidgrad_phi(23,23) = F(1,1);
        dgrad_chidgrad_phi(24,20) = F(2,1);
        dgrad_chidgrad_phi(24,24) = F(1,1);
        dgrad_chidgrad_phi(24,25) = F(0,1);
        dgrad_chidgrad_phi(25,20) = F(2,0);
        dgrad_chidgrad_phi(25,24) = F(1,0);
        dgrad_chidgrad_phi(25,25) = F(0,0);
        dgrad_chidgrad_phi(26,19) = F(1,0);
        dgrad_chidgrad_phi(26,21) = F(2,0);
        dgrad_chidgrad_phi(26,26) = F(0,0);

        return;
    }

    void compute_dgrad_chidF(const Vector_27 &grad_phi, SpMat &dgrad_chidF){
        /*!=============================
        |    compute_dgrad_chidF    |
        =============================
        
        Compute the gradient of grad_chi w.r.t. the deformation gradient.
        
        Note: We assume that grad_phi is a gradient of phi in the current configuration
        
        */
        //Initialize the tripletList
        std::vector<T> tripletList;
        tripletList.reserve(81);

        //Extract grad_phi
        double grad_phi111 = grad_phi(0);
        double grad_phi122 = grad_phi(1);
        double grad_phi133 = grad_phi(2);
        double grad_phi123 = grad_phi(3);
        double grad_phi113 = grad_phi(4);
        double grad_phi112 = grad_phi(5);
        double grad_phi132 = grad_phi(6);
        double grad_phi131 = grad_phi(7);
        double grad_phi121 = grad_phi(8);
        double grad_phi211 = grad_phi(9);
        double grad_phi222 = grad_phi(10);
        double grad_phi233 = grad_phi(11);
        double grad_phi223 = grad_phi(12);
        double grad_phi213 = grad_phi(13);
        double grad_phi212 = grad_phi(14);
        double grad_phi232 = grad_phi(15);
        double grad_phi231 = grad_phi(16);
        double grad_phi221 = grad_phi(17);
        double grad_phi311 = grad_phi(18);
        double grad_phi322 = grad_phi(19);
        double grad_phi333 = grad_phi(20);
        double grad_phi323 = grad_phi(21);
        double grad_phi313 = grad_phi(22);
        double grad_phi312 = grad_phi(23);
        double grad_phi332 = grad_phi(24);
        double grad_phi331 = grad_phi(25);
        double grad_phi321 = grad_phi(26);

        //Assemble dgrad_chidgrad_phi
        tripletList.push_back(T(0,0,grad_phi111));
        tripletList.push_back(T(0,7,grad_phi113));
        tripletList.push_back(T(0,8,grad_phi112));
        tripletList.push_back(T(1,1,grad_phi122));
        tripletList.push_back(T(1,5,grad_phi121));
        tripletList.push_back(T(1,6,grad_phi123));
        tripletList.push_back(T(2,2,grad_phi133));
        tripletList.push_back(T(2,3,grad_phi132));
        tripletList.push_back(T(2,4,grad_phi131));
        tripletList.push_back(T(3,2,grad_phi123));
        tripletList.push_back(T(3,3,grad_phi122));
        tripletList.push_back(T(3,4,grad_phi121));
        tripletList.push_back(T(4,2,grad_phi113));
        tripletList.push_back(T(4,3,grad_phi112));
        tripletList.push_back(T(4,4,grad_phi111));
        tripletList.push_back(T(5,1,grad_phi112));
        tripletList.push_back(T(5,5,grad_phi111));
        tripletList.push_back(T(5,6,grad_phi113));
        tripletList.push_back(T(6,1,grad_phi132));
        tripletList.push_back(T(6,5,grad_phi131));
        tripletList.push_back(T(6,6,grad_phi133));
        tripletList.push_back(T(7,0,grad_phi131));
        tripletList.push_back(T(7,7,grad_phi133));
        tripletList.push_back(T(7,8,grad_phi132));
        tripletList.push_back(T(8,0,grad_phi121));
        tripletList.push_back(T(8,7,grad_phi123));
        tripletList.push_back(T(8,8,grad_phi122));
        tripletList.push_back(T(9,0,grad_phi211));
        tripletList.push_back(T(9,7,grad_phi213));
        tripletList.push_back(T(9,8,grad_phi212));
        tripletList.push_back(T(10,1,grad_phi222));
        tripletList.push_back(T(10,5,grad_phi221));
        tripletList.push_back(T(10,6,grad_phi223));
        tripletList.push_back(T(11,2,grad_phi233));
        tripletList.push_back(T(11,3,grad_phi232));
        tripletList.push_back(T(11,4,grad_phi231));
        tripletList.push_back(T(12,2,grad_phi223));
        tripletList.push_back(T(12,3,grad_phi222));
        tripletList.push_back(T(12,4,grad_phi221));
        tripletList.push_back(T(13,2,grad_phi213));
        tripletList.push_back(T(13,3,grad_phi212));
        tripletList.push_back(T(13,4,grad_phi211));
        tripletList.push_back(T(14,1,grad_phi212));
        tripletList.push_back(T(14,5,grad_phi211));
        tripletList.push_back(T(14,6,grad_phi213));
        tripletList.push_back(T(15,1,grad_phi232));
        tripletList.push_back(T(15,5,grad_phi231));
        tripletList.push_back(T(15,6,grad_phi233));
        tripletList.push_back(T(16,0,grad_phi231));
        tripletList.push_back(T(16,7,grad_phi233));
        tripletList.push_back(T(16,8,grad_phi232));
        tripletList.push_back(T(17,0,grad_phi221));
        tripletList.push_back(T(17,7,grad_phi223));
        tripletList.push_back(T(17,8,grad_phi222));
        tripletList.push_back(T(18,0,grad_phi311));
        tripletList.push_back(T(18,7,grad_phi313));
        tripletList.push_back(T(18,8,grad_phi312));
        tripletList.push_back(T(19,1,grad_phi322));
        tripletList.push_back(T(19,5,grad_phi321));
        tripletList.push_back(T(19,6,grad_phi323));
        tripletList.push_back(T(20,2,grad_phi333));
        tripletList.push_back(T(20,3,grad_phi332));
        tripletList.push_back(T(20,4,grad_phi331));
        tripletList.push_back(T(21,2,grad_phi323));
        tripletList.push_back(T(21,3,grad_phi322));
        tripletList.push_back(T(21,4,grad_phi321));
        tripletList.push_back(T(22,2,grad_phi313));
        tripletList.push_back(T(22,3,grad_phi312));
        tripletList.push_back(T(22,4,grad_phi311));
        tripletList.push_back(T(23,1,grad_phi312));
        tripletList.push_back(T(23,5,grad_phi311));
        tripletList.push_back(T(23,6,grad_phi313));
        tripletList.push_back(T(24,1,grad_phi332));
        tripletList.push_back(T(24,5,grad_phi331));
        tripletList.push_back(T(24,6,grad_phi333));
        tripletList.push_back(T(25,0,grad_phi331));
        tripletList.push_back(T(25,7,grad_phi333));
        tripletList.push_back(T(25,8,grad_phi332));
        tripletList.push_back(T(26,0,grad_phi321));
        tripletList.push_back(T(26,7,grad_phi323));
        tripletList.push_back(T(26,8,grad_phi322));
        
        dgrad_chidF.setFromTriplets(tripletList.begin(), tripletList.end());
        return;
    }
    
    void compute_dgrad_chidF(const Vector_27 &grad_phi, Matrix_27x9 &dgrad_chidF){
        /*!=============================
        |    compute_dgrad_chidF    |
        =============================
        
        Compute the gradient of grad_chi w.r.t. the deformation gradient.
        
        Note: We assume that grad_phi is a gradient of phi in the current configuration
        
        */

        dgrad_chidF = Matrix_27x9::Zero();

        dgrad_chidF(0,0) = grad_phi(0,0);
        dgrad_chidF(0,7) = grad_phi(4,0);
        dgrad_chidF(0,8) = grad_phi(5,0);
        dgrad_chidF(1,1) = grad_phi(1,0);
        dgrad_chidF(1,5) = grad_phi(8,0);
        dgrad_chidF(1,6) = grad_phi(3,0);
        dgrad_chidF(2,2) = grad_phi(2,0);
        dgrad_chidF(2,3) = grad_phi(6,0);
        dgrad_chidF(2,4) = grad_phi(7,0);
        dgrad_chidF(3,2) = grad_phi(3,0);
        dgrad_chidF(3,3) = grad_phi(1,0);
        dgrad_chidF(3,4) = grad_phi(8,0);
        dgrad_chidF(4,2) = grad_phi(4,0);
        dgrad_chidF(4,3) = grad_phi(5,0);
        dgrad_chidF(4,4) = grad_phi(0,0);
        dgrad_chidF(5,1) = grad_phi(5,0);
        dgrad_chidF(5,5) = grad_phi(0,0);
        dgrad_chidF(5,6) = grad_phi(4,0);
        dgrad_chidF(6,1) = grad_phi(6,0);
        dgrad_chidF(6,5) = grad_phi(7,0);
        dgrad_chidF(6,6) = grad_phi(2,0);
        dgrad_chidF(7,0) = grad_phi(7,0);
        dgrad_chidF(7,7) = grad_phi(2,0);
        dgrad_chidF(7,8) = grad_phi(6,0);
        dgrad_chidF(8,0) = grad_phi(8,0);
        dgrad_chidF(8,7) = grad_phi(3,0);
        dgrad_chidF(8,8) = grad_phi(1,0);
        dgrad_chidF(9,0) = grad_phi(9,0);
        dgrad_chidF(9,7) = grad_phi(13,0);
        dgrad_chidF(9,8) = grad_phi(14,0);
        dgrad_chidF(10,1) = grad_phi(10,0);
        dgrad_chidF(10,5) = grad_phi(17,0);
        dgrad_chidF(10,6) = grad_phi(12,0);
        dgrad_chidF(11,2) = grad_phi(11,0);
        dgrad_chidF(11,3) = grad_phi(15,0);
        dgrad_chidF(11,4) = grad_phi(16,0);
        dgrad_chidF(12,2) = grad_phi(12,0);
        dgrad_chidF(12,3) = grad_phi(10,0);
        dgrad_chidF(12,4) = grad_phi(17,0);
        dgrad_chidF(13,2) = grad_phi(13,0);
        dgrad_chidF(13,3) = grad_phi(14,0);
        dgrad_chidF(13,4) = grad_phi(9,0);
        dgrad_chidF(14,1) = grad_phi(14,0);
        dgrad_chidF(14,5) = grad_phi(9,0);
        dgrad_chidF(14,6) = grad_phi(13,0);
        dgrad_chidF(15,1) = grad_phi(15,0);
        dgrad_chidF(15,5) = grad_phi(16,0);
        dgrad_chidF(15,6) = grad_phi(11,0);
        dgrad_chidF(16,0) = grad_phi(16,0);
        dgrad_chidF(16,7) = grad_phi(11,0);
        dgrad_chidF(16,8) = grad_phi(15,0);
        dgrad_chidF(17,0) = grad_phi(17,0);
        dgrad_chidF(17,7) = grad_phi(12,0);
        dgrad_chidF(17,8) = grad_phi(10,0);
        dgrad_chidF(18,0) = grad_phi(18,0);
        dgrad_chidF(18,7) = grad_phi(22,0);
        dgrad_chidF(18,8) = grad_phi(23,0);
        dgrad_chidF(19,1) = grad_phi(19,0);
        dgrad_chidF(19,5) = grad_phi(26,0);
        dgrad_chidF(19,6) = grad_phi(21,0);
        dgrad_chidF(20,2) = grad_phi(20,0);
        dgrad_chidF(20,3) = grad_phi(24,0);
        dgrad_chidF(20,4) = grad_phi(25,0);
        dgrad_chidF(21,2) = grad_phi(21,0);
        dgrad_chidF(21,3) = grad_phi(19,0);
        dgrad_chidF(21,4) = grad_phi(26,0);
        dgrad_chidF(22,2) = grad_phi(22,0);
        dgrad_chidF(22,3) = grad_phi(23,0);
        dgrad_chidF(22,4) = grad_phi(18,0);
        dgrad_chidF(23,1) = grad_phi(23,0);
        dgrad_chidF(23,5) = grad_phi(18,0);
        dgrad_chidF(23,6) = grad_phi(22,0);
        dgrad_chidF(24,1) = grad_phi(24,0);
        dgrad_chidF(24,5) = grad_phi(25,0);
        dgrad_chidF(24,6) = grad_phi(20,0);
        dgrad_chidF(25,0) = grad_phi(25,0);
        dgrad_chidF(25,7) = grad_phi(20,0);
        dgrad_chidF(25,8) = grad_phi(24,0);
        dgrad_chidF(26,0) = grad_phi(26,0);
        dgrad_chidF(26,7) = grad_phi(21,0);
        dgrad_chidF(26,8) = grad_phi(19,0);

        return;
    }

    void compute_dFdgrad_u(const Matrix_3x3 &F, Matrix_9x9 &dFdgrad_u){
        /*!============================
        |    commpute_dFdgrad_u    |
        ============================
        
        Compute the derivative of the deformation gradient w.r.t. 
        the gradient of the deformation.
        
        */
        
        
        //Matrix_3x3 Finv = F.inverse();
        Matrix_9x9 dFdFinv;
        compute_dAinvdA(F,dFdFinv);
        dFdgrad_u = -dFdFinv;

        return;
    }
    
    void compute_ddetAdA(const Matrix_3x3 &A, Matrix_3x3 &ddetAdA){
        /*!======================
        |    compute_dJdF    |
        ======================
        
        Compute the derivative of the determinant of the second order tensor A 
        w.r.t. A.
        
        */
        
        double detA = A.determinant();
        
        Matrix_3x3 Ainv = A.inverse();
        
        ddetAdA = detA*Ainv.transpose();
        
        return;
    }
    
    void map_stresses_to_current_configuration(const Matrix_3x3 &F, const Matrix_3x3 &chi,
                                               const Vector_9 &PK2, const Vector_9 &SIGMA, const Vector_27 &M,
                                               Vector_9 &cauchy, Vector_9 &s, Vector_27 &m){
        /*!===============================================
        |    map_stresses_to_current_configuration    |
        ===============================================

        Map the stresses to the current configuration.

        */

        //Compute the jacobian of deformation
        double Jac = F.determinant();

        //Map the PK2 stress to the cauchy stress
        Matrix_3x3 PK2_mat;
        undo_voigt_3x3_tensor(PK2,PK2_mat);
        voigt_3x3_tensor(F*PK2_mat*F.transpose()/Jac,cauchy);

        //Map the symmetric stress to the current configuration
        Matrix_3x3 SIGMA_mat;
        undo_voigt_3x3_tensor(SIGMA,SIGMA_mat);
        voigt_3x3_tensor(F*SIGMA_mat*F.transpose()/Jac,s);

        //Map the higher order stress to the current configuration
        Matrix_3x9 M_mat;
        undo_voigt_3x9_tensor(M,M_mat);
        voigt_3x9_tensor(F*M_mat,m);                 //Map the first index
        perform_left_positive_cyclic_permutation(m); //Cycle the indices
        undo_voigt_3x9_tensor(m,M_mat);
        voigt_3x9_tensor(F*M_mat,m);                 //Map the second index
        perform_left_positive_cyclic_permutation(m); //Cycle the indices
        undo_voigt_3x9_tensor(m,M_mat);
        voigt_3x9_tensor(chi*M_mat,m);               //Map the third index
        perform_left_positive_cyclic_permutation(m); //Cycle the indices
        m = m/Jac;

        return;
    }
    
    void map_jacobians_to_current_configuration(const Matrix_3x3  &F,            const Matrix_3x3  &chi,
                                                const Vector_9    &PK2_voigt,    const Vector_9    &SIGMA_voigt, const Vector_27    &M_voigt,
                                                const Vector_9    &cauchy_voigt, const Vector_9    &s_voigt,     const Vector_27    &m_voigt,
                                                const Matrix_9x9  &dPK2dF,       const Matrix_9x9  &dPK2dchi,    const Matrix_9x27  &dPK2dgrad_chi,
                                                const Matrix_9x9  &dSIGMAdF,     const Matrix_9x9  &dSIGMAdchi,  const Matrix_9x27  &dSIGMAdgrad_chi,
                                                const Matrix_27x9 &dMdF,         const Matrix_27x9 &dMdchi,      const Matrix_27x27 &dMdgrad_chi, 
                                                Matrix_9x9        &dcauchydF,    Matrix_9x9        &dcauchydchi, Matrix_9x27        &dcauchydgrad_chi,
                                                Matrix_9x9        &dsdF,         Matrix_9x9        &dsdchi,      Matrix_9x27        &dsdgrad_chi,
                                                Matrix_27x9       &dmdF,         Matrix_27x9       &dmdchi,      Matrix_27x27       &dmdgrad_chi){
    
        /*!================================================
        |    map_jacobians_to_current_configuration    |
        ================================================
        
        Function to map jacobians computed in the reference or intermediate configuration to 
        jacobians in the current configuration with respect to the fundamental deformation measures.
        
        Note: You should always write a test function for this in your code. It *should* work but 
              it is possible the previously written test coverage will miss a problem shown by
              your application.
        
        */
        
        //Compute the jacobian of deformation
        double J = F.determinant();
        
        //Compute the derivative of the jacobian of deformation w.r.t. F
        Matrix_3x3 dJdF;
        compute_ddetAdA(F,dJdF);
        
        //Map the cauchy stress
        map_dAdF_to_dadF(cauchy_voigt, PK2_voigt, dPK2dF, J, dJdF, F, dcauchydF);
        map_dAdchi_to_dadchi(dPK2dchi, J, F, dcauchydchi);
        map_dAdgrad_chi_to_dadgrad_chi(dPK2dgrad_chi, J, F, dcauchydgrad_chi);        
        
        //Map the symmetric stress
        map_dAdF_to_dadF(s_voigt, SIGMA_voigt, dSIGMAdF, J, dJdF, F, dsdF);
        map_dAdchi_to_dadchi(dSIGMAdchi, J, F, dsdchi);
        map_dAdgrad_chi_to_dadgrad_chi(dSIGMAdgrad_chi, J, F, dsdgrad_chi);
        
        //Map the higher order stress
        map_dAdF_to_dadF(m_voigt, M_voigt, dMdF, J, dJdF, F, chi, dmdF);
        map_dAdchi_to_dadchi(M_voigt, dMdchi, J, F, chi, dmdchi);
        map_dAdgrad_chi_to_dadgrad_chi(dMdgrad_chi, J, F, chi, dmdgrad_chi);
        
        return;
    }
    
    void map_dAdF_to_dadF(const Vector_9 &a,  const Vector_9 &A,  const Matrix_9x9 &dAdF,  const double &detF, const Matrix_3x3 &dJdF, const Matrix_3x3 &F, Matrix_9x9 &dadF){
        /*!==========================
        |    map_dAdF_to_dadF    |
        ==========================
        
        Map the jacobian of a stress measure in the reference configuration with respect to the 
        deformation gradient (either the PK2 stress or the symmetric stress) to the jacobian of 
        a corresponding stress measure in the current configuration (either the cauchy stress 
        or the symmetric stress) with respect to the deformation gradient.
        
        */
        
        double eye[3][3] = {{1,0,0},
                            {0,1,0},
                            {0,0,1}};

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int Ihat;
        int Jhat;
        int Khat;

        double tmp;
        double tmp1;
        double tmp2;
        double tmp3;
        
        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                Ihat = sot_to_voigt_map[i][j];
                for (int k=0; k<3; k++){
                    tmp1 = eye[i][k];
                    tmp2 = eye[j][k];
                    for (int K=0; K<3; K++){
                        Jhat = sot_to_voigt_map[k][K];
                        tmp = -dJdF(k,K)*a[Ihat];

                        if(tmp1>1e-9){
                            for (int J=0; J<3; J++){
                                Khat = sot_to_voigt_map[K][J];
                                tmp += F(j,J)*A(Khat);
                            }
                        }
                        
                        if(tmp2>1e-9){
                            for (int I=0; I<3; I++){
                                Khat = sot_to_voigt_map[I][K];
                                tmp += F(i,I)*A(Khat);
                            }
                        }

                        for (int I=0; I<3; I++){
                            tmp3 = F(i,I);
                            for (int J=0; J<3; J++){
                                Khat = sot_to_voigt_map[I][J];
                                tmp += tmp3*F(j,J)*dAdF(Khat,Jhat);
                            }
                        }
                        dadF(Ihat,Jhat) = tmp;
                    }
                }
            }
        }

        dadF /= detF;
        
        return;
    }

    void map_dAdF_to_dadF(const double (&a)[9],  const double (&A)[9],  const double (&dAdF)[9][9],  const double &detF, const double (&dJdF)[3][3], const double (&F)[3][3], double (&dadF)[3][3]){
        /*!==========================
        |    map_dAdF_to_dadF    |
        ==========================
        
        Map the jacobian of a stress measure in the reference configuration with respect to the 
        deformation gradient (either the PK2 stress or the symmetric stress) to the jacobian of 
        a corresponding stress measure in the current configuration (either the cauchy stress 
        or the symmetric stress) with respect to the deformation gradient.
        
        */
        
        double eye[3][3] = {{1,0,0},
                            {0,1,0},
                            {0,0,1}};

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int Ihat;
        int Jhat;
        int Khat;

        double tmp;
        double tmp1;
        double tmp2;
        double tmp3;
        
        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                Ihat = sot_to_voigt_map[i][j];
                for (int k=0; k<3; k++){
                    tmp1 = eye[i][k];
                    tmp2 = eye[j][k];
                    for (int K=0; K<3; K++){
                        Jhat = sot_to_voigt_map[k][K];
                        tmp = -dJdF[k][K]*a[Ihat];

                        if(tmp1>1e-9){
                            for (int J=0; J<3; J++){
                                Khat = sot_to_voigt_map[K][J];
                                tmp += F[j][J]*A[Khat];
                            }
                        }
                        
                        if(tmp2>1e-9){
                            for (int I=0; I<3; I++){
                                Khat = sot_to_voigt_map[I][K];
                                tmp += F[i][I]*A[Khat];
                            }
                        }

                        for (int I=0; I<3; I++){
                            tmp3 = F[i][I];
                            for (int J=0; J<3; J++){
                                Khat = sot_to_voigt_map[I][J];
                                tmp += tmp3*F[j][J]*dAdF[Khat][Jhat];
                            }
                        }
                        dadF[Ihat][Jhat] = tmp/detF;
                    }
                }
            }
        }

        return;
    }

    void map_dAdF_to_dadF(const Vector_27& a, const Vector_27 &A, const Matrix_27x9 &dAdF, const double &detF, const Matrix_3x3 &dJdF, const Matrix_3x3 &F, const Matrix_3x3 &chi, Matrix_27x9 &dadF){
        /*!==========================
        |    map_dAdF_to_dadF    |
        ==========================
        
        Map the jacobian of a stress measure in the reference configuration with respect to the 
        deformation gradient (either the PK2 stress or the symmetric stress) to the jacobian of 
        a corresponding stress measure in the current configuration (either the cauchy stress 
        or the symmetric stress) with respect to the deformation gradient.
        
        This is for the higher-order stress measure.
        
        */

        double eye[3][3] = {{1,0,0},
                            {0,1,0},
                            {0,0,1}};

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int tot_to_voigt_map[3][3][3];
        deformation_measures::get_tot_to_voigt_map(tot_to_voigt_map);

        int Ihat;
        int Jhat;
        int Khat;
        
        double tmp;
        double tmp1;
        double tmp2;
        double tmp3;
        double tmp4;

        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                for (int k=0; k<3; k++){
                    Ihat = tot_to_voigt_map[i][j][k];
                    for (int l=0; l<3; l++){
                        tmp1 = eye[i][l];
                        tmp2 = eye[j][l];
                        for (int L=0; L<3; L++){
                            Jhat = sot_to_voigt_map[l][L];
                            
                            tmp = -dJdF(l,L)*a[Ihat];

                            if(tmp1>1e-9){
                                for (int J=0; J<3; J++){
                                    tmp3 = F(j,J);
                                    for (int K=0; K<3; K++){
                                        Khat = tot_to_voigt_map[L][J][K];
                                        tmp += tmp3 * chi(k,K) * A(Khat);
                                    }
                                }
                            }

                            if(tmp2>1e-9){
                                for (int I=0; I<3; I++){
                                    tmp3 = F(i,I);
                                    for (int K=0; K<3; K++){
                                        Khat = tot_to_voigt_map[I][L][K];
                                        tmp += tmp3 * chi(k,K) * A(Khat);
                                    }
                                }
                            }

                            for (int I=0; I<3; I++){
                                tmp3 = F(i,I);
                                for (int J=0; J<3; J++){
                                    tmp4 = F(j,J);
                                    for (int K=0; K<3; K++){
                                        Khat = tot_to_voigt_map[I][J][K];
                                        tmp += tmp3 * tmp4 * chi(k,K) * dAdF(Khat,Jhat);
                                    }
                                }
                            }
                            dadF(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }

        dadF /= detF;
        return;
    }

    void map_dAdchi_to_dadchi(const Matrix_9x9 &dAdchi,  const double &detF, const Matrix_3x3 &F, Matrix_9x9 &dadchi){
        /*!==============================
        |    map_dAdchi_to_dadchi    |
        ==============================
        
        Map the jacobian of a stress measure w.r.t. chi in the reference configuration 
        to the current configuration.
        
        */
        
        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int Ihat;
        int Jhat;
        int Khat;
        
        double tmp;
        double tmp1;

        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                Ihat = sot_to_voigt_map[i][j];
                for (int k=0; k<3; k++){
                    for (int K=0; K<3; K++){
                        Jhat = sot_to_voigt_map[k][K];
                        tmp =  0;

                        for (int I=0; I<3; I++){
                            tmp1 = F(i,I);
                            for (int J=0; J<3; J++){
                                Khat = sot_to_voigt_map[I][J];
                                tmp += tmp1 * F(j,J) * dAdchi(Khat,Jhat);
                            }
                        }
                        dadchi(Ihat,Jhat) = tmp;
                    }
                }
            }
        }
        dadchi /= detF;
        
        return;
    }
    
    void map_dAdchi_to_dadchi(const Vector_27 &A, const Matrix_27x9 &dAdchi, const double &detF, const Matrix_3x3 &F, const Matrix_3x3 &chi, Matrix_27x9 &dadchi){
        /*!==============================
        |    map_dAdchi_to_dadchi    |
        ==============================
        
        Map the jacobian of a stress measure w.r.t. chi in the reference configuration 
        to the current configuration.
        
        For the higher-order stress
        
        */
       
        double eye[3][3] = {{1,0,0},
                            {0,1,0},
                            {0,0,1}};

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int tot_to_voigt_map[3][3][3];
        deformation_measures::get_tot_to_voigt_map(tot_to_voigt_map);

        int Ihat;
        int Jhat;
        int Khat;

        double tmp;
        double tmp1;
        double tmp2;
        double tmp3;        

        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                for (int k=0; k<3; k++){
                    Ihat = tot_to_voigt_map[i][j][k];
                    for (int l=0; l<3; l++){
                        tmp3 = eye[k][l];
                        for (int L=0; L<3; L++){
                            Jhat = sot_to_voigt_map[l][L];
                            tmp = 0;

                            if(tmp3>1e-6){
                                for (int I=0; I<3; I++){
                                    tmp1 = F(i,I);
                                    for (int J=0; J<3; J++){
                                        Khat = tot_to_voigt_map[I][J][L];
                                        tmp += tmp1 * F(j,J) * A(Khat);
                                    }
                                }
                            }

                            for (int I=0; I<3; I++){
                                tmp1 = F(i,I);
                                for (int J=0; J<3; J++){
                                    tmp2 = F(j,J);
                                    for (int K=0; K<3; K++){
                                        Khat = tot_to_voigt_map[I][J][K];
                                        tmp += tmp1 * tmp2 * chi(k,K) * dAdchi(Khat,Jhat);
                                    }
                                }
                            }
                            dadchi(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }

        dadchi /= detF;
        return;
    }

    void map_dAdgrad_chi_to_dadgrad_chi(const Matrix_9x27 &dAdgrad_chi,  const double &detF, const Matrix_3x3 &F, Matrix_9x27 &dadgrad_chi){
        /*!========================================
        |    map_dAdgrad_chi_to_dadgrad_chi    |
        ========================================
        
        Map the gradient of a stress tensor w.r.t. the gradient w.r.t. the reference coordinate X of the micro-deformation tensor 
        in the reference configuration to the current configuration.
        
        Note that grad_chi is chi_iI,J to the resulting gradient is dadgrad_chi_ijkK,L.
        */
        
        //double eye[3][3] = {{1,0,0},
        //                    {0,1,0},
        //                    {0,0,1}};

        int sot_to_voigt_map[3][3] = {{0,5,4},
                                      {8,1,3},
                                      {7,6,2}};

        int tot_to_voigt_map[3][3][3];
        deformation_measures::get_tot_to_voigt_map(tot_to_voigt_map);

        int Ihat;
        int Jhat;
        int Khat;

        double tmp;        
        double tmp1;

        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                Ihat = sot_to_voigt_map[i][j];
                for (int k=0; k<3; k++){
                    for (int K=0; K<3; K++){
                        for (int L=0; L<3; L++){
                            Jhat = tot_to_voigt_map[k][K][L];
                            tmp = 0;

                            for (int I=0; I<3; I++){
                                tmp1 = F(i,I);
                                for (int J=0; J<3; J++){
                                    Khat = sot_to_voigt_map[I][J];
                                    tmp += tmp1 * F(j,J) * dAdgrad_chi(Khat,Jhat);
                                }
                            }
                            dadgrad_chi(Ihat,Jhat) = tmp;
                        }
                    }
                }
            }
        }
 
        dadgrad_chi /= detF;
        return;
    }
    
    void map_dAdgrad_chi_to_dadgrad_chi(const Matrix_27x27 &dAdgrad_chi, const double &detF, const Matrix_3x3 &F, const Matrix_3x3 &chi, Matrix_27x27 &dadgrad_chi){
        /*!========================================
        |    map_dAdgrad_chi_to_dadgrad_chi    |
        ========================================
        
        Map the gradient of a stress tensor w.r.t. the gradient w.r.t. the reference coordinate X of the micro-deformation tensor 
        in the reference configuration to the current configuration.
        
        Note that grad_chi is chi_iI,J to the resulting gradient is dadgrad_chi_ijklK,L.
        
        This is for the higher order stress
        */
        
        int tot_to_voigt_map[3][3][3];
        deformation_measures::get_tot_to_voigt_map(tot_to_voigt_map);

        int Ihat;
        int Jhat;
        int Khat;
        
        double tmp;
        double tmp1;
        double tmp2;    

        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                for (int k=0; k<3; k++){
                    Ihat = tot_to_voigt_map[i][j][k];
                    for (int l=0; l<3; l++){
                        for (int L=0; L<3; L++){
                            for (int M=0; M<3; M++){
                                Jhat = tot_to_voigt_map[l][L][M];
                                tmp = 0;

                                for (int I=0; I<3; I++){
                                    tmp1 = F(i,I);
                                    for (int J=0; J<3; J++){
                                        tmp2 = F(j,J);
                                        for (int K=0; K<3; K++){
                                            Khat = tot_to_voigt_map[I][J][K];
                                            tmp += tmp1 * tmp2 * chi(k,K) * dAdgrad_chi(Khat,Jhat);
                                        }
                                    }
                                }
                                dadgrad_chi(Ihat,Jhat) = tmp;
                            }
                        }
                    }
                }
            }
        }

        dadgrad_chi /= detF;
        return;
    }

    void map_dAdgrad_chi_to_dadgrad_chi(const double (&dAdgrad_chi)[27][27], const double &detF, const double (&F)[3][3], const double (&chi)[3][3], double (&dadgrad_chi)[27][27]){
        /*!========================================
        |    map_dAdgrad_chi_to_dadgrad_chi    |
        ========================================
        
        Map the gradient of a stress tensor w.r.t. the gradient w.r.t. the reference coordinate X of the micro-deformation tensor 
        in the reference configuration to the current configuration.
        
        Note that grad_chi is chi_iI,J to the resulting gradient is dadgrad_chi_ijklK,L.
        
        This is for the higher order stress
        */
        
        int tot_to_voigt_map[3][3][3];
        deformation_measures::get_tot_to_voigt_map(tot_to_voigt_map);

        int Ihat;
        int Jhat;
        int Khat;
        
        double tmp;
        double tmp1;
        double tmp2;    

        for (int i=0; i<3; i++){
            for (int j=0; j<3; j++){
                for (int k=0; k<3; k++){
                    Ihat = tot_to_voigt_map[i][j][k];
                    for (int l=0; l<3; l++){
                        for (int L=0; L<3; L++){
                            for (int M=0; M<3; M++){
                                Jhat = tot_to_voigt_map[l][L][M];
                                tmp = 0;

                                for (int I=0; I<3; I++){
                                    tmp1 = F[i][I];
                                    for (int J=0; J<3; J++){
                                        tmp2 = F[j][J];
                                        for (int K=0; K<3; K++){
                                            Khat = tot_to_voigt_map[I][J][K];
                                            tmp += tmp1 * tmp2 * chi[k][K] * dAdgrad_chi[Khat][Jhat];
                                        }
                                    }
                                }
                                dadgrad_chi[Ihat][Jhat] = tmp/detF;
                            }
                        }
                    }
                }
            }
        }

        return;
    }
    
    void compute_total_derivatives(const Matrix_3x3  &F,         const Vector_27    &grad_phi,
                                   const Matrix_9x9  &dcauchydF, const Matrix_9x27  &dcauchydgrad_chi,
                                   const Matrix_9x9  &dsdF,      const Matrix_9x27  &dsdgrad_chi,
                                   const Matrix_27x9 &dmdF,      const Matrix_27x27 &dmdgrad_chi,
                                   Matrix_9x9  &DcauchyDgrad_u,  Matrix_9x27  &DcauchyDgrad_phi,
                                   Matrix_9x9  &DsDgrad_u,       Matrix_9x27  &DsDgrad_phi,
                                   Matrix_27x9 &DmDgrad_u,       Matrix_27x27 &DmDgrad_phi){
        /*!===================================
        |    compute_total_derivatives    |
        ===================================

        Compute the total derivatives of the deformation measures w.r.t. the displacement degrees of freedom and their 
        gradients.
        
        Note DxDchi = DxDphi because chi = eye + phi
        
        */        

        //Define the partial derivatives of grad_chi
        //Note: Removing sparse matrices because of problems with 
        //      MOOSE.
        //SpMat dgrad_chidF(27,9);
        //SpMat dgrad_chidgrad_phi(27,27);

        Matrix_27x9  dgrad_chidF;
        Matrix_27x27 dgrad_chidgrad_phi;
        
        //Define the derivative of the deformation gradient w.r.t. the gradient of u w.r.t. the local coordinates.
        Matrix_9x9 dFdgrad_u;
        compute_dFdgrad_u(F,dFdgrad_u);
        
        compute_dgrad_chidF(grad_phi, dgrad_chidF);
        compute_dgrad_chidgrad_phi(F,dgrad_chidgrad_phi);
        
        //Compute the total derivatives w.r.t. the deformation gradient.
        DcauchyDgrad_u = (dcauchydF + dcauchydgrad_chi*dgrad_chidF)*dFdgrad_u;
        DsDgrad_u      = (dsdF      +      dsdgrad_chi*dgrad_chidF)*dFdgrad_u;
        DmDgrad_u      = (dmdF      +      dmdgrad_chi*dgrad_chidF)*dFdgrad_u;
        
        //Compute the total derivatives w.r.t. the gradient of the micro-displacement dof.
        DcauchyDgrad_phi = dcauchydgrad_chi*dgrad_chidgrad_phi;
        DsDgrad_phi      = dsdgrad_chi*dgrad_chidgrad_phi;
        DmDgrad_phi      = dmdgrad_chi*dgrad_chidgrad_phi;
        
        return;
    }
}
